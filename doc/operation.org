#+title: Operation

* Overview
Broadly, the radar works by emitting a frequency ramp signal that
reflects off a remote object and is detected by a receiver. Because
the transmitted signal ramps at a known rate and travels through air
at the speed of light, the frequency difference between the
transmitted and received signals can be used to determine the distance
to the remote object.

** Note to the reader
A number of sections go into significant detail about various parts of
the radar. This information is not necessary to understand what the
radar does and broadly how it does it. Furthermore, it can even
distract from these goals. Still, I believe this information is
important, especially for people attempting to understand the radar in
detail and reproduce it themselves, and so I've kept it in. I've
placed the detailed information in subsections with links at the top
of those sections to the next high-level section. I hope that by
making it easy to skip these sections, this documentation will
simultaneously be useful to people who just want the overview and to
people who want to go into more detail.

* Physics
** Operating principle
The distance to a remote object is

\(\begin{aligned}
d &= \frac{c\Delta t}{2} \\
\end{aligned}\)

where \(\Delta t\) is the time delay between the transmitted and received
signals and \(c\) is the speed of light in air. The factor of \(2\)
accounts for the fact that the signal must travel the round-trip
distance. The transmitted and received signals at the input to the
mixer (see the [[id:012a28eb-d2bd-4cf4-8eed-832482c535cf][block diagram section]]) are shown in the plot below (as
pictured, these are sawtooth ramp signals with a time delay between
ramps).

\begin{latex}
\def\off{0.1}
\def\sep{0.3}
\begin{tikzpicture}[
declare function={
  f(\x) = and(\x >= 0, \x < 1) * \x
          + and(\x >= 1, \x < 3) * 0
          + and(\x >= 3, \x < 4) * (\x-3)
          + and(\x >= 4, \x < 6) * 0
          + and(\x >= 6, \x < 7) * (\x-6)
          + and(\x >= 7, \x < 9) * 0
          + and(\x >= 9, \x < 10) * (\x-9);
},
declare function={
  tx(\x) = f(x-\off)+\off;
},
declare function={
  rx(\x) = f(x-\off-\sep)+\off;
}
]
\begin{axis}[
  title=FMCW Tx - Rx Signal Delay,
  xlabel={$t$},
  ylabel={$f$},
  width=15cm, height=8cm,
  axis x line=bottom,
  axis y line=left,
  legend entries={tx, rx},
  legend style={
    fill=bg,
    draw=fgcolor
  },
  xmin=0, ymin=0,
  set layers=axis on top,
  xtick=\empty,
  ytick=\empty,
]
  \addplot[
    domain=0:7,
    samples=1000
  ]
  {tx(x)};
  \addplot[
    blue!20,
    domain=0:7,
    samples=1000
  ]
  {rx(x)};
  \draw[dashed] (axis cs:3.3,0.3) --++(axis cs:\sep,0);
  \draw ($(axis cs:3.3,0.3)+(axis cs:\sep/2,0)$) node[below,fill=bg] {$\Delta t$};
  \draw[dashed] (axis cs:3.3+\sep,0.3) --++(axis cs:0,\sep);
  \draw ($(axis cs:3.3+\sep,0.3)+(axis cs:0,\sep/2)$) node[right,fill=bg] {$\Delta f$};
\end{axis}
\end{tikzpicture}
\end{latex}

The ramp slope and duration are explicitly programmed. So, by finding
the frequency difference between the transmitted and received signals,
we can find the time difference and thus the distance:

\(\begin{aligned}
\Delta t &= \frac{\Delta f}{f_{\mathit{ramp}}} \\
d &= \frac{c \Delta f}{2 f_{\mathit{ramp}}} \\
\end{aligned}\)

To find the frequency difference we note that the transmitted signal
has the form (note that I've restricted \(t\) and \(t-\Delta t\) to be
within the bounds of a single ramp period)

\(\begin{aligned}
s_{t}(t) &= T \sin\left(\omega(t) t\right)
  && \text{$T$ is the transmission signal amplitude} \\
&= T \sin\left(2 \pi f(t) t\right) \\
&= T \sin\left(2 \pi t \left( f_0 + t \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}
  \right) \right) \\
\end{aligned}\)

The received signal is just a time-delayed copy of the transmitted
signal with a different amplitude. The amplitude changes because
energy is lost as the wave propogates through air. Energy is
proportional to the amplitude squared.

\(\begin{aligned}
s_r(t) &= \frac{R}{T} s_t(t-\Delta t) \\
s_r(t) &= R \sin\left(\omega(t-\Delta t) \left(t-\Delta t\right)\right) \\
&= R \sin\left(2 \pi f(t-\Delta t) \left(t-\Delta t\right)\right) \\
\end{aligned}\)

We can write this expression equivalently as

\(\begin{aligned}
s_r &= R \sin{\left(at - a\Delta t\right)} \\
\end{aligned}\)

where \(a=2\pi f(t-\Delta t)\). It's easy to see that this is
approximately equal to \(R \sin{\left(at\right)}\). Look back at our
distance equation in terms of the time delay. The max distance we'll
try to detect is \(250\si{m}\) (more on this later). Using that value,
we see that the maximum time delay is less than \(1.7\si{\mu s}\). In
contrast the value of \(t\) during a sweep ranges from
\(0-1\si{ms}\). So, for almost the entire ramp period, it's fair to
assume \(t>>\Delta t\). Using this approximation, the equation for our
received signal turns into

\(\begin{aligned}
s_r(t) &= R \sin\left(2 \pi t \left( f_0 + (t -\Delta t)
  \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}\right)\right) \\
\end{aligned}\)

The product of two sine functions can be equivalently represented as

\(\begin{aligned}
\sin{\theta} \sin{\phi} &=
  \frac{1}{2} \left[ \cos{\left(\theta - \phi\right)}
  - \cos{\left(\theta + \phi\right)} \right] \\
\end{aligned}\)

In other words, as a combination of a sinusoid of the frequency sum
and a sinusoid of the frequency difference. It's precisely the
frequency difference that we want. Moreover, the frequency sum will be
much higher than the frequency difference (about 4 orders of magnitude
in our case). As a result, the circuitry that we use to pick up the
difference frequency won't detect the sum frequency. Using this
knowledge, we see that if we multiply the transmitted and received
signals we get

\(\begin{aligned}
m &= TR \sin\left(2 \pi t \left( f_0 + t \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}
  \right) \right) \sin\left(2 \pi t \left( f_0 + (t -\Delta t) \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}
  \right) \right) \\
&\approx TR \sin{\left(2\pi t \Delta t
  \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}\right)} \\
&\approx TR \sin{\left(2\pi t \Delta f\right)} \\
\end{aligned}\)

So, using a Fourier transform on the mixer output will tell us the
frequency difference and thus the distance.

** TODO Maximum range
The maximum range of a radar can be determined using the radar
equation, presented below.

\(\begin{aligned}
R_{max} &= \sqrt[4]{\frac{P_t G^2 \lambda^2 \sigma}
  {P_{min}\left(4\pi\right)^3}} \\
\end{aligned}\)

where \(P_t\) is the transmitted power, \(G\) is the antenna gain,
\(\lambda\) is the wavelength of our signal frequency, \(\sigma\) is
the target cross-sectional area, and \(P_{min}\) is the minimum
detectable signal power. I'll present the values here, but I will
additionally explain how I got to them in the [[id:2892ed74-7258-4776-ae3d-a5a417dda02c][transmitter]] and [[id:5b91918a-80ec-4cff-af24-e620558c087a][receiver]]
sections.

TODO the transmitted power (antenna efficiency) and antenna gain need
to be simulated, and are in general not in accordance with the values
presented in the original PDF.

For the wavelength, we use the center frequency of \(5.6\si{GHz}\)
(\(\lambda = c/f_0\)), which corresponds to a wavelength of roughly
\(5.4\si{cm}\). For the cross-sectional area we'll somewhat
arbitrarily take \(1\si{m^2}\). It's worth noting for smaller objects
that the max distance is proportional to the square root of one
dimension of the remote object (assuming square objects). So, cutting
the dimension in half (\(0.5\times 0.5\si{m}\)) makes the range
roughly \(2/3\) of what we could expect previously.

TODO minimum detectable power. See the PDF.

** TODO Minimum range
See the PDF. Also, I'm not sure if this should be its own
section. Maybe they should be subsections under a "Range" section.

** TODO Angle calculation
** TODO Additional considerations
*** TODO Doppler shift
See PDF.

* Block Diagram
:PROPERTIES:
:ID:       012a28eb-d2bd-4cf4-8eed-832482c535cf
:END:

\begin{latex}
\newdimen\XCoord
\newdimen\YCoord
\newcommand*{\ExtractCoordinate}[1]{\path (#1); \pgfgetlastxy{\XCoord}{\YCoord};}%
\ctikzset{resistors/scale=0.4}
% tx
\begin{circuitikz}[color=fgcolor]
\draw (6,0) node[coupler](cpl){};
\ExtractCoordinate{cpl.3}
\draw (10,\YCoord) node[bareTXantenna](tx){Tx};
\draw (cpl.3) -- (tx.bottom);
\draw (cpl.1) --++(-0.5,0) to[R] ++(0,-1) node[tlground]{};
\draw ($(cpl.4)-(6,0)$) node[oscillator](fs){};
\draw (fs.east) to[amp,t=PA] (cpl.4);
\draw (fs.north) node[above]{Frequency};
\draw (fs.south) node[below]{Synthesizer};
% rx
\ExtractCoordinate{tx.center};
\draw (\XCoord, -4) node[bareRXantenna, xscale=-1](rx){\scalebox{-1}[1]{Rx}};
\draw (rx.center) to[short] ++(-2,0)
  to[amp,t={\scalebox{-1}[-1]{\footnotesize LNA}}] ++(-2,0)
  to[amp,t={\scalebox{-1}[-1]{RF}}] ++(-2,0) coordinate (n1);
\draw (3, -4) node[mixer](mix){};
\draw (n1) to[short] (mix.3);
\ExtractCoordinate{mix.4};
\draw (cpl.2) --++(1,0) --++(0,-2) -| (mix.4);
\draw (mix.1) --++(-0.5,0) to[bandpass] ++(-2,0) to[amp,t={\scalebox{-1}[-1]{IF}}]
  ++(-2,0) to[adc] ++(-2,0) --++(0,-2) coordinate (fpga) --++(0,-2)
  to[twoport,t=FIR] ++(2,0) to[twoport,t=$20\downarrow$] ++(2,0)
  to[twoport,name=window] ++(2,0) to[fft] ++(2,0) to[short,-o] ++(1,0)
  node[right] {PC};
\draw (window.north) node[above] {Window};
\draw[dashed] ($(fpga)-(2,0)$) -- ($(fpga)+(8,0)$) node[below
  left]{FPGA} -- ($(fpga)+(8,-4)$);
\end{circuitikz}
\end{latex}
#+caption: FMCW radar block diagram. Note that downsampling is
#+caption: actually performed as part of the FIR filter (not after)
#+caption: for efficiency reasons. Functionally, the result is
#+caption: identical.

A frequency synthesizer generates a sinusoidal signal that ramps in
frequency from \(5.3\) to \(5.9\si{GHz}\) over a duration of
\(1\si{ms}\). The signal is then amplified and most of the power is
sent to the transmission antenna. The remaining power is redirected to
a mixer for multiplication with the received signal. The light echo of
the transmitted signal is picked up by a reception antenna and
amplified with a low-noise amplifier followed by a high-frequency
amplifier. This amplified signal is mixed with the coupled portion of
the transmitted signal and output as a differential signal. The mixer
output is passed through a bandpass filter, which has a flat frequency
response between about \(10\si{kHz}\) and \(1\si{MHz}\). The signal is
then amplified again, digitized at a sampling rate of \(40\si{MHz}\),
and passed to the FPGA. The FPGA first uses a polyphase FIR filter to
simultaneously filter signals of frequency greater than \(1\si{MHz}\)
and downsample the signal by a factor of 20 which reduces the
computational load for subsequent processing/transmission stages. The
signal is then multiplied by a kaiser window and finally transformed
into its frequency composition with a 1024-point FFT. The frequency
bins are then sent to a host PC for further processing and realtime
plotting.

* Transmitter
:PROPERTIES:
:ID:       2892ed74-7258-4776-ae3d-a5a417dda02c
:END:
The transmitter consists of a frequency synthesizer, VCO
(voltage-controlled oscillator), and power amplifier, along with an
amplifier, wilkinson power divider, several attenuators, and a
directional coupler.

\begin{circuitikz}[color=fgcolor]
\ctikzset{multipoles/dipchip/width=2}
\ctikzset{resistors/scale=0.4}
\ctikzset{capacitors/scale=0.4}
\ctikzset{grounds/scale=0.6}
\draw (0,0) node[dipchip, num pins=10, hide numbers, no topmark,
  external pins width=0](fs){ADF4158};
\draw (fs.n) --++(0,0.5) node[vcc]{};
\draw (fs.s) --++(0,-0.5) node[ground]{};
\draw (fs.bpin 9) node[left, font=\tiny] {CP};
\draw (fs.bpin 7) node[left, font=\tiny] {$f_{\text{VCO}}$};
\draw (fs.w) node[right,font=\tiny]{$f_{\text{in}}$};
\draw (fs.w) to[short,-o] ++(-0.5,0);
\draw (fs.bpin 9) to[short,-*] ++(0.5,0) coordinate(cp) to[amp] ++(2,0)
  to[vco] ++(1,0) to[TL] ++(2,0) node[wilkinson,anchor=in](wilk){};
\draw (cp) to[C] ++(0,-0.75) node[tlground]{};
\draw (wilk.out2) to[tattenuator,label=\SI{5}{dB}] ++(2,0) to[amp,t=PA] ++(2,0)
  node[coupler,anchor=4](coupler){\SI{20}{dB}};
\draw (coupler.3) --++(1,0) node[bareTXantenna,anchor=center]{};
\draw (coupler.1) --++(-0.5,0) to[R] ++(0,-1) node[tlground]{};
\draw (coupler.2) --++(0.5,0) --++(0,-1) node[inputarrow,rotate=-90]{}
  node[below]{to receiver};
\draw (wilk.out1) --++(0.5,0) --++(0,-1)
  to[tattenuator,mirror,label=\SI{3}{dB}] ++(-7,0) |- (fs.bpin 7);
\end{circuitikz}
#+caption: Transmitter block diagram.

I included a single transmission line after the VCO to indicate that a
transmission line with characteristic impedance of \(\SI{50}{\Omega}\)
is required for each connection after the VCO (I've ommitted most of
them to save space). The [[id:f361bbcc-7225-453e-a107-3f4793e4dd4a][RF simulation section]] describes how to design
the microstrip transmission line.

** Frequency Synthesizer
The ADF4158 frequency synthesizer is based on a fractional-N PLL
(phase-locked loop) design. Chapter 13 of the Art of Electronics (3e)
provides an excellent description of how a PLL works. I explain the
relevant points here. The frequency synthesizer consists of a phase
detector and VCO (our VCO is an external component). It looks like
this (note that this diagram, along with the phase detector and VCO
diagrams are adapted from AoE).

\begin{circuitikz}[color=fgcolor]
\draw[->] (0,0) node[left]{$f_{\mathit{REF}}$} to[short,o-] ++(1,0)
  node[twoportshape,t=$\div r$,anchor=w](r){};
\draw[->] (r.e) --++(1,0) node[fourport,anchor=4,t=$\phi$-detector](det){};
\draw[->] ($(det.3)!0.5!(det.2)$) --++(1,0) coordinate(c1);
\draw (c1) node[vcoshape,anchor=w](vco){};
\draw[->] (vco.e) --++(2,0) node[right]{$f_{\mathit{VCO}}$};
\draw[->] (vco.e) ++(1,0) to[short,*-] ++(0,-1.5) --++(-1,0)
  node[twoportshape,t=$\div n$,anchor=e](n){};
\draw[->] (n.w) --++(-3.5,0) |- (det.1);
\end{circuitikz}

The phase detector, as the name suggests, outputs a voltage signal
which corresponds to the difference in phase between two input
frequencies. The VCO generates a frequency that is proportional to an
input voltage. Forget the frequency divider blocks for a minute. We'll
get back to them. \(f_{\mathit{REF}}\) is a reference frequency. In
our case this is a \(\SI{40}{MHz}\) clock frequency. Imagine that the
rising edge of \(f_{\mathit{REF}}\) occurs before the rising edge of
\(f_{\mathit{VCO}}\). In response, the phase detector increases it's
output voltage corresponding to the duration of time that
\(f_{\mathit{REF}}\) leads \(f_{\mathit{VCO}}\). This causes the VCO
output frequency to increase accordingly and the next edge of the VCO
output to occur sooner than the previous one. So, the phase gap
diminishes. The opposite occurs when \(f_{\mathit{REF}}\) lags behind
\(f_{\mathit{VCO}}\). The phase detector is detecting differences in
phase, not frequency. However, any differences in frequency will lead
to phase differences and thus the phase detector will cause the
frequency and phase of \(f_{\mathit{VCO}}\) to converge to that of
\(f_{\mathit{REF}}\). It's worth noting that we're talking about
signal edges even though \(f_{\mathit{VCO}}\) is a sinusoidal
signal. We can use a Schmitt trigger to turn this into a fast edge.

All we've done so far is take \(f_{\mathit{REF}}\) and generate
another signal \(f_{\mathit{VCO}}\) with identical frequency and
phase, which isn't particularly useful. This is where the frequency
dividers come in. The R divider takes \(f_{\mathit{REF}}\) and outputs
a frequency \(f_{\mathit{REF}}/r\). The N divider does the same thing
for \(f_{\mathit{VCO}}\). So, what we're doing is setting

\(\begin{aligned}
\frac{f_{\mathit{VCO}}}{n} &= \frac{f_{\mathit{REF}}}{r}\\
f_{\mathit{VCO}} &= f_{\mathit{REF}} \left(\frac{n}{r}\right)\\
\end{aligned}\)

By setting \(n\) much larger than \(r\), we can generate an output
frequency that is much higher than the reference frequency. The
diagram above isn't completely accurate. What we've shown is an
integer-N frequency synthesizer, whereas the device we're using is a
fractional-N frequency synthesizer. The practical difference is that
our value of \(n\) can be non-integral and thus allows more precise
control of the output voltage.

*** Phase Detector
I've ommitted some important details about how the phase-detector
controls the voltage input to the VCO, which I'll discuss now.

Here's a possible implementation of a phase detector, taken from AoE.

\begin{circuitikz}[color=fgcolor]
\ctikzset{flipflops/scale=0.8}
\draw (0,0) node[flipflop D, add async SR](ff1){};
\draw (0,-3) node[flipflop D, add async SR](ff2){};
\draw ($(ff1.pin 1)+(-1,1)$) node[above]{$V_+$} to[short,o-*] ++(0,-1) coordinate(c1)
  --++(1,0);
\draw (c1) |- (ff2.pin 1);
\draw (ff1.pin 3) to[short,-o] ++(-2,0) node[left]{$f_{\mathit{REF}}$};
\draw (ff2.pin 3) to[short,-o] ++(-2,0) node[left]{$f_{\mathit{VCO}}$};
\draw (ff1.pin 6) to[short,-*] ++(2,0) coordinate(c2);
\draw[->] (c2) --++(4,0) coordinate(c3);
\draw (c3) node[isourceAMshape,anchor=s,rotate=-90](i1){};
\draw (ff2.pin 6) to[short,-*] ++(2,0) coordinate(c4);
\draw[->] (c4) --++(4,0) coordinate(c5);
\draw (c5) node[isourceAMshape,anchor=s,rotate=-90](i2){};
\draw ($(c2)!0.5!(c4)+(2,0)$) node[american and port](and){};
\draw (c2) |- (and.in 1);
\draw (c4) |- (and.in 2);
\draw (and.out) --++(0.5,0) --++(0,-4) --++(-0.5,0) node[american not
  port,anchor=in,xscale=-1](n1){};
\draw (n1.out) --++(-0.5,0) node[american not port,anchor=in,xscale=-1](n2){};
\draw (n2.out) --++(-0.5,0) coordinate(c7) -| (ff2.down);
\draw (c7) to[short,*-] ++(0,3.5) --++(-0.5,0) -| (ff1.down);
\draw (i1.w) --++(0,1) node[vcc]{};
\draw (i2.e) --++(0,-1) node[ground](gnd){};
\draw (i1.e) -- (i2.w);
\draw ($(i1.e)!0.5!(i2.w)$) to[short,*-*] ++(2,0) coordinate(c6)
  to[short,-o] ++(2,0) node[right]{$V_{\mathit{out}}$};
\gettikzxy{(gnd)}{\gndx}{\gndy}
\gettikzxy{(c6)}{\cx}{\cy}
\draw (c6) to[C] ++(0,\gndy-\cy) node[ground]{};
\end{circuitikz}

A high voltage level at the left input of each current source
activates the current source. Ignore the NOT buffers for now, I'll
discuss them in a minute. A positive voltage is constantly applied to
the D-input of each flip-flop. The outputs are set (brought to
digital 1) when the rising edge of the clock signal appears. Because
of the AND gate, both outputs are cleared (brought down to digital 0)
when both outputs are simultaneously set. Therefore, each flip-flop's
current source is only active for the duration of time when its
flip-flop is set and the other flip-flop is not set. The current
sources act as a charge pump. The top current source charges up the
capacitor and thus increases the voltage across it linearly with time
\(dV=(I/C)dt\). Similarly, the bottom current source decreases the
voltage across the capacitor. In other words, we are able to increase
or decrease the voltage to the VCO proportional to the phase lag
between the two signals.

Even if the purpose of the NOT gates is not immediately clear, it
should be easy to see that they are harmless. That is, the effect of
both current sources being active simultaneously is the same as both
being inactive since the bottom current source will sink all the
current from the top source and the voltage across the capacitor will
remain unchanged. The delay provided by the chained NOT gates is
necessary to ensure phase-locking when the phase difference between
the signals becomes very small. The reason for this is that the
transistor used to implement the current source has a parasitic
capacitance between the base and emitter, or gate and
source. Therefore the voltage difference between the terminals has a
nonzero rise time and so for very short activation periods, the
base-emitter or gate-source voltage will never rise enough to allow
the transistor to conduct, preventing the frequencies from ever
locking.

* Receiver
:PROPERTIES:
:ID:       5b91918a-80ec-4cff-af24-e620558c087a
:END:
* USB Interface
:PROPERTIES:
:ID:       cecb79d6-db88-42bb-90b1-c61545fa00fc
:END:
* FPGA
:PROPERTIES:
:ID:       6d0ccb21-c85b-417a-961e-5bbfb78717d9
:END:
A top-level block diagram of the FPGA logic is shown below. The data
output by the ADC (see [[id:5b91918a-80ec-4cff-af24-e620558c087a][receiver]]) enters the FPGA and is demultiplexed
into channels A and B, corresponding to the two receivers. For a
simple range detection (i.e. ignoring incident angle), channel B is
dropped. Channel A is input to a [[id:feb22339-7b6b-495b-9432-3999c179b164][polyphase FIR decimation filter]] that
filters out frequencies above 1MHz and downsamples from 40MHz to
2MHz. The FIR output is then passed through a [[id:0a0cea3d-b2d1-4b95-bc76-719e0f499fec][kaiser window]], followed
by an asynchronous FIFO, which is read by the [[id:5535c7fa-c614-4b3e-ac41-efa5581223b6][FFT module]] at 40MHz. The
FFT real and imaginary outputs are time-multiplexed and written to
another asynchronous FIFO.

When the bitstream is fully loaded onto the FPGA, the FPGA control
logic immediately begins configuring the [[id:a0e92e3e-3444-4956-8c07-b4d14d1f2489][ADF4158 frequency
synthesizer]], which is enabled at the end of configuration. The
frequency synthesizer emits a voltage pulse on the muxout line at the
end of each frequency ramp. The onboard ADF4158 control logic counts
the appropriate delay and turns this into a ramp start signal that the
control unit (CU) uses to synchronize the data processing pipeline to
the ramp period. The FIR filter and kaiser window are enabled
simultaneously (ignoring a small delay for the FIR latency). Once the
FIFO is full, the FIR filter and kaiser windows are disabled and the
FFT is enabled. The data processing pipeline waits for the next ramp
start signal before recommencing. If the FT245 write FIFO is not empty
when the ramp start is signaled (more on this in a minute), the CU
delays another full ramp period and then tries again.

The PC (see [[id:a434cb1f-9f49-407b-aa58-2d561982d98d][the software section]]) is able to request the data it wants
from the FPGA. The FT245 module (which is an interface to the FT2232H
USB interface chip, see [[id:cecb79d6-db88-42bb-90b1-c61545fa00fc][USB interface]]) reads a command from the PC and
selects the corresponding step in the data processing pipeline to send
to the PC. Writing from the FPGA to PC is also controlled by the same
FT245 module. The PC has the option of receiving the raw ADC data
(both channels), the FIR filtered output, the kaiser window output, or
the fully-processed FFT output.

\begin{circuitikz}[color=fgcolor]
\ctikzset{multipoles/dipchip/width=6/5}
\tikzset{demux/.style={muxdemux, muxdemux def={Lh=1, Rh=2, NL=1, NB=0,
  NR=2, w=1}}}
\tikzset{smallMux/.style={muxdemux, muxdemux def={Lh=2, Rh=1, NL=2, NB=0,
  NR=1, w=1}}}
\tikzset{largeMux/.style={muxdemux, muxdemux def={Lh=4, Rh=2, NL=4, NB=0,
  NT=1, NR=1, w=1.5}}}
\def\block{node[dipchip, num pins=6, hide numbers, no topmark, external
  pins width=0,anchor=bpin 2]}
\def\blockTop{node[dipchip, num pins=6, hide numbers, no topmark, external
  pins width=0,anchor=n]}
\def\smallBlock{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=n]}
\def\smallBlockRight{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=bpin 2]}
\def\smallBlockLeft{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=bpin 1]}
\def\smallBlockBottom{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=s]}
\def\pcblock{node[dipchip, num pins=4, hide numbers, no topmark, external
  pins width=0,anchor=bpin 3]}
%% ADF4158 and control
\draw (0,0) node[left]{\footnotesize muxout} --++(2,0)
  node[inputarrow]{} \block(adf){\footnotesize ADF4158};
\draw (adf.bpin 5) to[short] ++(1.5,0) node[inputarrow]{}
  \block(control){\footnotesize CU};
%% ADC
\draw (0,-3) node[left]{\footnotesize adc\_d\_i} --++(2,0)
  node[inputarrow]{} node[demux, anchor=west](demux){};
%% processing blocks
\draw ($(adf.bpin 5)!0.5!(control.bpin 2)$) node[above]{\tiny ramp start};
\draw (control.bpin 4) -|++(1,-1) node[inputarrow,rotate=-90]{} coordinate (b);
\draw (b) node[below]{\tiny en} \blockTop(fir){\footnotesize FIR};
\draw (fir.bpin 5) --++(1,0) node[inputarrow]{}
  \block(kaiser){\footnotesize kaiser};
\draw ($(fir.bpin 5)!0.5!(kaiser.bpin 2)$) node[above]{\tiny
  2MHz} coordinate(firOut);
\draw (control.bpin 5) -| (kaiser.n) node[inputarrow,rotate=-90]{}
  node[below]{\tiny en};
\draw (kaiser.bpin 5) --++(1,0) node[inputarrow]{}
  \block(fifo){\footnotesize FIFO};
\draw ($(kaiser.bpin 5)!0.5!(fifo.bpin 2)$) coordinate(kaiserOut);
\draw (fifo.bpin 5) --++(1,0) node[inputarrow]{}
  \block(fft){\footnotesize FFT};
\draw ($(fifo.bpin 5)!0.5!(fft.bpin 2)$) node[above]{\tiny 40MHz};
\draw (control.bpin 6) -| (fft.n) node[inputarrow,rotate=-90]{}
  node[below]{\tiny en};
%% ADC to FIR
\draw (demux.rpin 1) node[above right]{\tiny chA} --++(1,0) |-
  (fir.bpin 2) node[inputarrow]{};
\draw (demux.rpin 2) node[right]{\tiny chB} node[ocirc,fill=bg]{};
%% data output
\draw ($(fft.s)-(0.28,0)$) node[above]{\tiny Im}
  --++(0,-0.5) coordinate (fftIm);
\draw ($(fft.s)+(0.28,0)$) node[above]{\tiny Re}
  --++(0,-0.5) coordinate (fftRe);
\draw (fftIm) node[smallMux,anchor=lpin 2,rotate=-90](smallMux){};
\draw (smallMux.rpin 1) --++(0,-0.3) node[left]{\tiny 80MHz}
  --++(0,-0.7) coordinate(c) \smallBlock(ellipsisBlock){\tiny
  \textellipsis};
\draw (ellipsisBlock.s) \smallBlock(imblock){\tiny Im};
\draw (imblock.s) \smallBlock(reblock){\tiny Re};
\draw (reblock.s) --++(0,-1) node[inputarrow,rotate=-90]{}
  \blockTop(fifob){\footnotesize FIFO};
\gettikzxy{(control.bpin 5)}{\controlRightX}{\controlRightY}
\gettikzxy{(fifob.bpin 2)}{\fifoBLeftX}{\fifoBLeftY}
\draw (fifob.bpin 2) node[above left]{\tiny 40MHz}
  --++(\controlRightX-\fifoBLeftX,0) node[largeMux,anchor=lpin
  4,xscale=-1](largemux){};
\gettikzxy{(adf.bpin 5)}{\adfRightX}{\adfRightY}
\gettikzxy{(largemux.rpin 1)}{\largemuxOutX}{\largemuxOutY}
\draw (largemux.rpin 1) --++(\adfRightX-\largemuxOutX,0)
  node[inputarrow,rotate=180]{} \smallBlockRight(wrfifo){\tiny write
  FIFO};
\draw (wrfifo.n) \smallBlockBottom(rdfifo){\tiny read FIFO};
\draw (rdfifo.n) node[above]{\footnotesize FT245};
\draw (rdfifo.bpin 2) --++(0.25,0) |-++(0.25,1.5) node[inputarrow]{}
  \smallBlockLeft(controlb){\footnotesize control};
\draw (controlb.bpin 2) -| (largemux.tpin 1) node[left]{\tiny
  OP STATE};
\draw (firOut) to[short,*-] ++(0,-1) |- (largemux.lpin 2);
\draw (kaiserOut) to[short,*-] ++(0,-1) |- (largemux.lpin 3);
\draw (1.5,-3) node[above]{\tiny 40MHz} to[short,*-] ++(0,-1)
  --++(6,0) |- (largemux.lpin 1);
\gettikzxy{(wrfifo.bpin 1)}{\wrfifoLeftX}{\wrfifoLeftY}
\draw (wrfifo.bpin 1) --++(-\wrfifoLeftX,0)
  node[inputarrow,rotate=180]{} \pcblock(pc){\footnotesize PC};
\draw (pc.bpin 4) -- (rdfifo.bpin 1) node[inputarrow]{};
%% PCB and PC demarcation
\draw[dashed] (0.5,1) node[below left]{\footnotesize PCB} |- (-1,-4);
\draw[dashed] (-1,-7) -| (0.5,-11);
\end{circuitikz}

** FIR Polyphase Decimation Filter
:PROPERTIES:
:ID:       feb22339-7b6b-495b-9432-3999c179b164
:END:
The FIR polyphase decimation filter has two functions: it filters out
signals above 1MHz and downsamples the data to 2MHz. 1MHz corresponds
to the maximum distance we're interested in detecting and the new 2MHz
sampling rate ensures we stay above the Nyquist rate to avoid
aliasing.

We can't downsample before filtering because that would alias signals
above 1MHz into our filtered output. However, filtering before
downsampling would require us to perform filtering on the full 40MHz
input, which is inefficient because most of this data would be
immediately discarded. Fortunately, we can use a polyphase decimation
filter to get the best of both worlds (see the [[id:491617b7-7ba2-4a76-9a68-89ff7f8608b9][implementation section]]
for details).

*** Implementation
:PROPERTIES:
:ID:       491617b7-7ba2-4a76-9a68-89ff7f8608b9
:END:
Next high-level section: [[id:0a0cea3d-b2d1-4b95-bc76-719e0f499fec][Kaiser Window]]

In order for our polyphase decimation FIR filter to work it needs to
produce results identical what we'd get if we first filtered our
signal and then downsampled. Our input signal arrives at 40MHz and
then we downsample to 2MHz by only keeping every 20th signal.

Start with the normal equation for an FIR filter:

\(\begin{aligned}
  y[n] &= (h*x)(n) = \sum_{k=0}^{N-1} h[k] x[n-k]\\
\end{aligned}\)

\(x[n]=x[0],x[1],\ldots\) is our input sequence where \(x[0]\) is the
first sample, etc. \(h[n]\) is the filter's impulse response (I use a
120-tap filter) which we precompute in software (I've used scipy, see
the code for details). We need 1024 post-downsampling samples for the
FFT. Expanding this out, we get

\(\begin{aligned}
  y[0] &= h[0]x[0] \\
  y[1] &= h[0]x[1] + h[1]x[0] \\
  y[2] &= h[0]x[2] + h[1]x[1] + h[2]x[0] \\
  &\ldots \\
  y[20] &= h[0]x[20] + h[1]x[19] + \ldots + h[20]x[0] \\
  &\ldots \\
  y[119] &= h[0]x[119] + h[1]x[118] + \ldots + h[119]x[0] \\
  y[120] &= h[0]x[120] + h[1]x[119] + \ldots + h[119]x[1] \\
  &\ldots \\
\end{aligned}\)

The pattern is easy to see, but let me draw your attention to the last
term of the last equation in case you rushed through it. Specifically,
once the number of coefficients becomes less than the historical
number of inputs, we drop the oldest input each time we add a new
input. None of this is different than a normal FIR filter yet.

The difference comes in noticing that the only results we want after
filtering and downsampling are

\(\begin{aligned}
  y[0] &= h[0]x[0] \\
  y[20] &= h[0]x[20] + h[1]x[19] + \ldots + h[20]x[0] \\
  y[40] &= h[0]x[40] + h[1]x[39] + \ldots + h[40]x[0] \\
  y[60] &= h[0]x[60] + h[1]x[59] + \ldots + h[60]x[0] \\
  &\ldots \\
  y[120] &= h[0]x[120] + h[1]x[119] + \ldots + h[119]x[1] \\
  &\ldots \\
\end{aligned}\)

And these should arrive at the output at a frequency of 2MHz.

We need to figure out how to compute this directly; i.e. without
filtering and then downsampling as we did above. The schematic below
implements this.

\begin{circuitikz}[color=fgcolor]
\ctikzset{flipflops/scale=0.5}
\ctikzset{blocks/scale=0.3}
\ctikzset{multipoles/flipflop/font=\scriptsize}
\tikzset{flipflop ff/.style={flipflop,
  flipflop def={t1=D, c3=1, t6=Q}}
}
\def\bank#1#2#3#4#5#6#7#8{%
  \draw #1 node[flipflop ff, anchor=pin 1](ff0){};
  \draw (ff0.pin 3) --++(-0.25,0) node[left]{\tiny $\SI{2}{MHz}$};
  \draw ($(ff0.pin 1)-(0.25,0)$) coordinate(ffout0);
  \draw (ffout0) --++(0,0.5) node[mixer,anchor=2](mix0){};
  \draw (mix0.1) --++(-0.25,0) node[left]{\tiny #2};
  \draw (ff0.pin 6) --++(0.25,0) coordinate(ffout1)
    --++(0.25,0) node[flipflop ff, anchor=pin 1](ff){};
  \draw (ffout1) --++(0,0.5) node[mixer,anchor=2](mix){};
  \draw (mix.1) --++(-0.25,0) node[left]{\tiny #3};
  \draw (mix.3) -|++(0.1,0.5) node[adder,anchor=2](add){};
  \draw (mix0.3) --++(0.1,0) |-(add.1);
  \draw (ff0.pin 3) --++(0,-0.5) -| (ff.pin 3);
  \foreach \coeff in {#4, #5, #6} {
    \gettikzxy{(ff.pin 3)}{\fflastclkx}{\fflastclky}
    \draw (ff.pin 6) --++(0.25,0) coordinate(ffout)
    --++(0.25,0) node[flipflop ff, anchor=pin 1](ff){};
    \draw (ffout) --++(0,0.5) node[mixer,anchor=2](mix){};
    \draw (mix.1) --++(-0.25,0) node[left]{\tiny \coeff};
    \gettikzxy{(add.3)}{\addlastx}{\addlasty}
    \draw (mix.3) -|++(0.1,0.5) node[adder,anchor=2](add){};
    \draw (\addlastx,\addlasty) -- (add.1);
    \draw ($(\fflastclkx,\fflastclky)-(0,0.5)$) -| (ff.pin 3);
  }
  \draw (ff.pin 6) --++(0.25,0) node[mixer,anchor=1](mix){};
  \draw (mix.4) --++(0,0.25) node[above]{\tiny #7};
  \draw (mix.3) --++(0.25,0) node[adder,anchor=1](addnew){};
  \draw (add.3) -| (addnew.4);
  \draw (addnew.3) coordinate(#8);
}
\draw (0,0) node[left]{$x[n]$} --++(1,0) coordinate(a)
--++(3,0) coordinate(b);
\bank{(b)}{$h[0]$}{$h[20]$}{$h[40]$}{$h[60]$}{$h[80]$}{$h[100]$}{outa};
\draw (a) |-++(0.25,-1.5) node[flipflop ff, anchor=pin 1](ff1){};
\draw (ff1.pin 3) --++(-1,0) node[left]{\tiny $\SI{40}{MHz}$};
\draw (ff1.pin 6) -|++(0.25,-2.5) coordinate(c);
\gettikzxy{(a)}{\ax}{\ay}
\gettikzxy{(b)}{\bx}{\by}
\gettikzxy{(c)}{\cx}{\cy}
\draw (c) --++(\bx-\cx,0) coordinate(d);
\bank{(d)}{$h[1]$}{$h[21]$}{$h[41]$}{$h[61]$}{$h[81]$}{$h[101]$}{outb};
\draw (c) --++(\ax-\cx,0) |-++(0.25,-1.5) node[flipflop ff, anchor=pin 1](ff2){};
\draw (ff2.pin 6) -|++(0.25,-2.5) coordinate(d);
\draw (d) --++(\bx-\cx,0) coordinate(e);
\bank{(e)}{$h[2]$}{$h[22]$}{$h[42]$}{$h[62]$}{$h[82]$}{$h[102]$}{outc};
\draw ($(ff1.pin 3)-(0.75,0)$) |- (ff2.pin 3);
\draw ($(ff2.pin 3)-(0.75,0)$) --++(0,-3) coordinate(f);
\gettikzxy{(d)}{\dx}{\dy}
\gettikzxy{(f)}{\fx}{\fy}
\draw (d) --++(\ax-\cx,0) --++(0,\fy-\dy) coordinate(g);
\draw ($(f)+(0.25,-0.5)$) node[]{\Huge $\ldots$};
\draw ($(g)-(0,1)$) |-++(0.25,-1.5) node[flipflop ff, anchor=pin 1](ff3){};
\draw ($(f)-(0,1)$) |-(ff3.pin 3);
\draw (ff3.pin 6) -|++(0.25,-2.5) coordinate(h);
\draw (h) --++(\bx-\cx,0) coordinate(i);
\bank{(i)}{$h[19]$}{$h[39]$}{$h[59]$}{$h[79]$}{$h[99]$}{$h[119]$}{outd};
\draw (outc) --++(2,0) node[dipchip, num pins=10, hide numbers, no
topmark, external pins width=0, anchor=bpin 3](adder){\Huge $+$};
\draw (outa) --++(1,0) |- (adder.bpin 1);
\draw (outb) --++(0.5,0) |- (adder.bpin 2);
\draw (adder.bpin 4) node[left]{$\ldots$};
\draw (outd) --++(0.5,0) |- (adder.bpin 5);
\draw (adder.bpin 8) --++(1,0) node[right]{$y[n]$};
\end{circuitikz}

The leftmost (vertically stacked) flip-flops make up a shift register
clocked at 40MHz. Each horizontal set of flip flops make up another
shift register, all clocked at 2MHz. The first input, \(x[0]\), will
be registered in the leftmost flip-flop of the top 2MHz shift
register. It will also be multiplied by \(h[0]\) and pass to the
output so that the first output value is \(y[0]=h[0]x[0]\) as
expected. The horizontal shift registers will not register another
input until the new input is \(x[20]\) and the vertical shift register
has values, \(x[19]\), \(x[18]\), \(\ldots\) and \(x[1]\), proceeding
from the top flip flop down. The corresponding output will be the sum
of \(h[0]x[20]\), \(h[1]x[19]\), \(h[2]x[18]\), \(\ldots\),
\(h[19]x[1]\), and \(h[20]x[0]\), which comes from the second
multiplier in the top shift register. It's easy to follow this pattern
and see that we get the intended output.

You may have observed that if we were to follow this diagram
precisely, we would need 120 multiplication blocks. That's
significantly more than the 45 DSP slices we get on our XC7A15T
FPGA. Luckily, we can deviate from the diagram and use our multiplies
much more efficiently. The key to this is to notice that DSP slices
can be clocked at a much higher frequency (typically several hundred
MHz) than the frequency we're using them at (2MHz). So, by
time-multiplexing DSP slices we can use significantly fewer physical
multiply blocks than in the naive implementation. Theoretically, we
should be able to use a single DSP element for all 120
multiplies. However, I've used 10 (each DSP element is shared by 2
filter banks), which simplifies the control logic. Additionally, by
using the multiplies more efficiently, the number of DSP elements is
no longer the resource-limiting factor. Instead, we're limited by the
number of flip-flops needed for the filter banks. In the current
implementation we have 120 filter bank memory elements that must each
store 12 bits, which means 1440 flip-flops. We have room to increase
this, but a 120-tap filter should be good enough. We could potentially
cut down on resources by replacing the filter bank flip-flops with
time-multiplexed block RAM in much the same way as the DSP
slices. However, this is not that easy because the output of every
filter bank memory element must be available at every 2MHz clock
pulse. Since we're already time-multiplexing the multiplies, we would
need to synchronize this with the RAM access. This is worth pursuing
if we run low on resources or need a better filter. Otherwise, the
current implementation should be sufficient for our needs.

** Kaiser Window
:PROPERTIES:
:ID:       0a0cea3d-b2d1-4b95-bc76-719e0f499fec
:END:
Windowing is used to reduce spectral leakage in our input signal
before performing an FFT on that signal. This section's subsections
describe [[id:d6b994f0-0684-404f-ba91-36ab68e4f6b1][what spectral leakage is]], [[id:f4a4c107-8006-4ed5-ab5c-5ecfedc450e1][how windowing helps to reduce it]],
and [[id:b3437309-97a4-47fc-b51f-9ac373300bf8][how to implement a window function on an FPGA]].

*** Spectral Leakage
:PROPERTIES:
:ID:       d6b994f0-0684-404f-ba91-36ab68e4f6b1
:END:
Next high-level section: [[id:5535c7fa-c614-4b3e-ac41-efa5581223b6][FFT]]

Spectral leakage occurs when an operation introduces frequencies into
a signal that were not present in the original signal. In our case,
spectral leakage is due to an implicit rectangular window performed on
our input by taking a finite-duration subsample of the original
signal. The plots below illustrate this effect for a single-frequency
sinusoidal input.

\begin{tikzpicture}
\def\freq{4.5}
\begin{groupplot}[
  group style={group size=1 by 3, vertical sep=1cm},
  axis x line=middle,
  axis y line=middle,
  height=4cm, width=10cm,
  xmin=-2*pi, xmax=2*pi,
  ymin=-1.5, ymax=1.5,
  xtick=\empty, xticklabels=\empty,
  ytick=\empty, yticklabels=\empty,
  xticklabel style={
    fill=bg
  },
]
  \nextgroupplot[
    title={\footnotesize Pure Sine Wave Input},
    xlabel={$t$},
    ylabel={$A$},
  ]
  \addplot[
    domain=-2*pi:2*pi,
    samples=1000,
    blue!20,
  ] {sin(deg(\freq*x))};

  \nextgroupplot[
    title={\footnotesize Implicit Rectangular Window},
  ]
  \addplot[
    domain=-pi:pi,
    samples=100,
    blue!20,
  ] {1};
  \addplot[
    domain=-2*pi:-pi,
    samples=100,
    blue!20,
  ] {0};
  \addplot[
    domain=pi:2*pi,
    samples=100,
    blue!20,
  ] {0};
  \draw[blue!20] (axis cs:(-pi,0) -- (-pi,1));
  \draw[blue!20] (axis cs:(pi,0) -- (pi,1));

  \nextgroupplot[
    title={\footnotesize Actual Input},
  ]
  \addplot[
    domain=-pi:pi,
    samples=500,
    blue!20,
  ] {sin(deg(\freq*x))};
  \addplot[
    domain=-2*pi:-pi,
    samples=100,
    blue!20,
  ] {0};
  \addplot[
    domain=pi:2*pi,
    samples=100,
    blue!20,
  ] {0};
  \draw[blue!20] (axis cs:(-pi,0) -- (-pi,sin(deg(\freq*-pi))));
  \draw[blue!20] (axis cs:(pi,0) -- (pi,sin(deg(\freq*pi))));
\end{groupplot}
\end{tikzpicture}

We see that the beginning and end of the sample sequence jump from
zero to some nonzero value. This corresponds to a range of frequency
components not present in the original signal but that we can detect
in the FFT output. Note that we could eliminate the spectral leakage
by windowing an exact integral number of periods of the input
signal. But, we can't rely on being able to do this, especially for
signals composed of multiple frequencies.

Let's use some example sample sequences to illustrate the various
effects spectral leakage can have.

Start with a simple sinusoid with frequency 1Hz. We'll always ensure
the sampling rate is at or above the Nyquist rate to avoid aliasing.

The first plot shows the input sample sequence.

#+header: :file data/spectral-leakage-ex1-seq.dat
#+header: :session spectral-leakage
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
ts = f / 3
fs = 1 / ts
t = np.arange(0, 5.1 * f, step=ts)
s = np.sin(2*np.pi*f*t)
print("time signal")
for x, y in zip(t, s):
    print("{:.5f} {:.5f}".format(x, y))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$t$},
  axis x line=middle,
  axis y line=middle,
  set layers=axis on top,
  xticklabel style={
    fill=bg
  }
]
  \addplot[
    domain=0:5,
    samples=500,
  ] {sin(deg(2*pi*x))};
  \addplot[
    only marks,
    mark options={blue!50,scale=0.75},
  ] table[x=time, y=signal] {data/spectral-leakage-ex1-seq.dat};
\end{axis}
\end{tikzpicture}

This yields the fourier transform output

#+header: :file data/spectral-leakage-ex1-fft.dat
#+header: :session spectral-leakage
#+begin_src python :results output silent file :hidden
fft = np.absolute(np.fft.rfft(s))
fft /= np.sum(fft)
bins = np.fft.rfftfreq(len(t))
print("bin fft")
for x, y in zip(bins, fft):
    print("{:.5f} {:.5f}".format(x * fs, y))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$f$},
  set layers=axis on top,
  xtick=data,
  xticklabel style={
    font=\footnotesize,
    fill=bg
  },
  ybar,
]
  \addplot[fill=blue!75] table[x=bin, y=fft] {data/spectral-leakage-ex1-fft.dat};
\end{axis}
\end{tikzpicture}

If the FFT were correctly representing the true input signal, the
entire spectral content would be within the 0.94Hz frequency bin (this
includes the 1Hz frequency). The fact that it also registers spectral
content at other frequencies is the spectral leakage.

If we change the phase of the input signal, the output will change as
well, which shows the dependence of our output on uncontrolled
variations in the input.

#+header: :file data/spectral-leakage-ex2-seq.dat
#+header: :session spectral-leakage2
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
ts = f / 3
fs = 1 / ts
t = np.arange(0, 5.1 * f, step=ts)
s = np.sin(2*np.pi*f*t + (f/2))
print("time signal")
for x, y in zip(t, s):
    print("{:.5f} {:.5f}".format(x, y))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$t$},
  axis x line=middle,
  axis y line=middle,
  set layers=axis on top,
  xticklabel style={
    fill=bg
  }
]
  \addplot[
    domain=0:5,
    samples=500,
  ] {sin(deg(2*pi*x+(1/2)))};
  \addplot[
    only marks,
    mark options={blue!50,scale=0.75},
  ] table[x=time, y=signal] {data/spectral-leakage-ex2-seq.dat};
\end{axis}
\end{tikzpicture}

#+header: :file data/spectral-leakage-ex2-fft.dat
#+header: :session spectral-leakage2
#+begin_src python :results output silent file :hidden
fft = np.absolute(np.fft.rfft(s))
fft /= np.sum(fft)
bins = np.fft.rfftfreq(len(t))
print("bin fft")
for x, y in zip(bins, fft):
    print("{:.5f} {:.5f}".format(x * fs, y))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$f$},
  set layers=axis on top,
  xtick=data,
  xticklabel style={
    font=\footnotesize,
    fill=bg
  },
  ybar,
  legend entries={original, phase-shifted},
  legend pos=north west,
  legend style={
    fill=bg,
    draw=fgcolor
  },
]
  \addplot[fill=fgcolor] table[x=bin, y=fft] {data/spectral-leakage-ex1-fft.dat};
  \addplot[blue!75,fill=blue!75] table[x=bin, y=fft] {data/spectral-leakage-ex2-fft.dat};
\end{axis}
\end{tikzpicture}

The plot below shows the effect of using a larger FFT on the spectral
leakage. Namely, the leakage still exists, but is less
pronounced. This is expected since in the limit that the FFT length
approaches infinity, the spectral leakage should disappear.

#+header: :file data/windowing-purpose.dat
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
ts = f / 3
fs = 1 / ts

x = [np.arange(i, step=ts) for i in (5.1, 1e3 + 0.1)]
y = [np.sin(2 * np.pi * f * i) for i in x]
fft = [np.absolute(np.fft.rfft(i)) for i in y]
sample_bins = [np.fft.rfftfreq(len(i)) for i in x]
# rebin all ffts to first fft bins so they can be compared
fft_rebin = [np.zeros(len(sample_bins[0])) for i in range(len(x))]
for i, bin_cmp in enumerate(sample_bins[0]):
    if i < len(sample_bins[0]) - 1:
        next_bin = sample_bins[0][i + 1]
    else:
        # choice of 1 is arbitrary, just needs to be at least an
        # additional interval
        next_bin = bin_cmp + 1
    for bin_idx in range(1, len(x)):
        bins = sample_bins[bin_idx]
        for j, bin_other in enumerate(bins):
            if bin_other >= bin_cmp and bin_other < next_bin:
                fft_rebin[bin_idx][i] += fft[bin_idx][j]

fft_rebin[0] = fft[0]
# normalize fft
fft_norm = [i / np.sum(i) for i in fft_rebin]
print("{:5}  {:10}  {:10}".format("bin", "fft0", "fft1"))
for i, bin_val in enumerate(sample_bins[0]):
    print(
        "{:.3f}  {:.8f}  {:.8f}".format(
            bin_val * fs, fft_norm[0][i], fft_norm[1][i]
        )
    )
#+end_src

\begin{tikzpicture}
\begin{axis}[
  title=Spectral Leakage (FFT Length Effect),
  xlabel={$f$},
  ylabel={FFT Amplitude},
  ybar,
  legend entries={$N=16$, $N=3001$},
  legend pos=north west,
  legend style={
    fill=bg,
    draw=fgcolor
  },
  set layers=axis on top,
  xticklabel style={
    fill=bg
  }
]
  \addplot[fill=fgcolor] table[x=bin, y=fft0] {data/windowing-purpose.dat};
  \addplot[blue!75, fill=blue!75] table[x=bin, y=fft1] {data/windowing-purpose.dat};
\end{axis}
\end{tikzpicture}

*** Effect of Windowing on Spectral Leakage
:PROPERTIES:
:ID:       f4a4c107-8006-4ed5-ab5c-5ecfedc450e1
:END:
Certain window functions are effective at reducing spectral
leakage. For example,

#+header: :file data/window-spectral-leakage.dat
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
fs = 3 * f
ts = 1 / fs

t = np.arange(15.1, step=ts)
kaiser = np.kaiser(len(t), 6)
s = np.sin(2*np.pi*f*t)
s_kaiser = np.multiply(s, kaiser)
bins = np.fft.rfftfreq(len(s))
fft = np.absolute(np.fft.rfft(s))
fft /= np.sum(fft)
fft_kaiser = np.absolute(np.fft.rfft(s_kaiser))
fft_kaiser /= np.sum(fft_kaiser)

print("bin unwindowed windowed")
for bin_val, fft_val, fft_kaiser_val in zip(bins, fft, fft_kaiser):
    print("{:.5f} {:.5f} {:.5f}".format(bin_val * fs, fft_val, fft_kaiser_val))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  title=Effect of Windowing on Spectral Leakage,
  xlabel={$f$},
  ylabel={FFT Amplitude},
  legend entries={no window, window},
  legend style={
    fill=bg,
    draw=fgcolor
  },
  legend pos=north west,
  set layers=axis on top,
  xticklabel style={
    fill=bg
  },
  ybar,
  bar width=3pt,
]
  \addplot[fill=fgcolor] table[x=bin, y=unwindowed] {data/window-spectral-leakage.dat};
  \addplot[
    blue!50,
    fill=blue!50,
  ] table[x=bin, y=windowed] {data/window-spectral-leakage.dat};
\end{axis}
\end{tikzpicture}

We see that for the windowed function, the spectral content outside
the immediate vicinity of the signal frequency is almost zero. To
understand how the window works, it is informative to compare the
original time-domain signal with the time-domain signal after
windowing.

#+header: :file data/window-spectral-leakage-time-domain.dat
#+header: :session window-spectral-leakage
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
fs = 3 * f
ts = 1 / fs

t = np.arange(5.1, step=ts)
kaiser = np.kaiser(len(t), 6)
s = np.sin(2*np.pi*f*t)
s_kaiser = np.multiply(s, kaiser)
print("time orig windowed")
for time, s_orig, s_kais in zip(t, s, s_kaiser):
        print("{:.5f} {:.5f} {:.5f}".format(time, s_orig, s_kais))
#+end_src

#+header: :file data/window-spectral-leakage-time-domain-full-sine.dat
#+header: :session window-spectral-leakage
#+begin_src python :results output silent file :hidden
tfine = np.linspace(0, 5, num=1000)
kaiser_fine = np.kaiser(len(tfine), 6)
sfine = np.sin(2*np.pi*f*tfine)
sfine_kaiser = np.multiply(sfine, kaiser_fine)
print("time s")
for time, s in zip(tfine, sfine_kaiser):
        print("{:.5f} {:.5f}".format(time, s))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$t$},
  axis x line=middle,
  axis y line=middle,
  set layers=axis on top,
  xticklabel style={
    fill=bg
  }
]
  \addplot[
    domain=0:5,
    samples=500,
  ] {sin(deg(2*pi*x))};
  \addplot[
    only marks,
    mark options={scale=0.75},
  ] table[x=time, y=orig] {data/window-spectral-leakage-time-domain.dat};
  \addplot[
    blue!50,
  ] table[x=time, y=s] {data/window-spectral-leakage-time-domain-full-sine.dat};
  \addplot[
    only marks,
    mark options={blue!50,scale=0.75},
  ] table[x=time, y=windowed] {data/window-spectral-leakage-time-domain.dat};
\end{axis}
\end{tikzpicture}

We see that the kaiser window works by reducing the strength of the
signal at the beginning and end of the sequence. This makes sense,
since it is these parts of the sample that create the discontinuities
and generate frequencies not present in the original signal.

*** TODO Choosing a Window Function
Check [[https://www.electronicdesign.com/technologies/analog/article/21798689/choose-the-right-fft-window-function-when-evaluating-precision-adcs][this link]].

*** Implementation
:PROPERTIES:
:ID:       b3437309-97a4-47fc-b51f-9ac373300bf8
:END:
A window function works by simply multiplying the input signal by the
window coefficients. Therefore, implementing one on an FPGA is very
easy. We can use numpy to generate the coefficients for us, write
these values in hexadecimal format to a file and load them into an
FPGA rom with ~readmemh~. See the ~window~ module for details. The
only possibly difficult part is [[id:b7eba33e-b557-4af0-80cb-5e0fa982b567][convergent rounding]].

** FFT
:PROPERTIES:
:ID:       5535c7fa-c614-4b3e-ac41-efa5581223b6
:END:
** ADF4158 Frequency Synthesizer
:PROPERTIES:
:ID:       a0e92e3e-3444-4956-8c07-b4d14d1f2489
:END:
** Additional Considerations
*** Formal Verification
*** Convergent Rounding
:PROPERTIES:
:ID:       b7eba33e-b557-4af0-80cb-5e0fa982b567
:END:
*** Automated Testing
* PC Software
:PROPERTIES:
:ID:       a434cb1f-9f49-407b-aa58-2d561982d98d
:END:
* RF Simulations
** Microstrip
:PROPERTIES:
:ID:       f361bbcc-7225-453e-a107-3f4793e4dd4a
:END:
*** via fence
*** SMT ground cutout
** Wilkinson power divider
** Attenuator
** SMA connector
** Couplers
*** 3dB
*** 5dB
*** 6dB
** Antennas
*** Horn
*** Patch Array
* Spice Simulations
* OLD
** block diagram
** physics
This FMCW radar can compute the 2-dimensional position to remote
objects. It does this by computing the range and angle. Unlike some
other radars, this radar does not measure doppler shift and as a
result does not directly measure the speed of remote objects. However,
the speed can be computed by taking the change in position over time.

*** range
The distance computation is performed by measuring the time between
when a signal is transmitted and when it is received after having
bounced off a remote object. Using the relationship between the speed
of light and time of travel, we can back out the distance to a remote
target.

\(\displaystyle
d = \frac{ct_d}{2}
\)

In order to measure the round-trip travel time, we transmit a
sinusoidal signal that ramps in frequency at a predetermined rate
between predetermined start and stop frequencies. The frequency-time
graph of the transmitted and received signals is shown below.

#+caption: FMCW frequency ramp.
[[./data/fmcw-principle.png]]

Since we know the ramp rate and duration of one ramp, we can replace
our dependence on round-trip time with a dependence on frequency
difference between our transmitted and received signals.

\(\displaystyle
d = \frac{ct_{\text{ramp}} \Delta f}{2f_{\text{ramp}}}
\)

Take the equation for a transmitted signal as

\(\begin{aligned}
  s_{\text{t}}(t) &= T \sin\left(\omega_{\text{t}}(t) t\right)  && \text{$T$ is the transmitted
                                                                   signal's amplitude.} \\
                  &= T \sin\left(2 \pi f(t) t\right) \\
                  &= T \sin\left(2 \pi t \left( f_0 + t \frac{f_{\text{ramp}}}{t_{\text{ramp}}}
                    \right) \right)
\end{aligned}\)

The corresponding received signal is (ignoring the doppler shift which
is insignificant at the speeds we care about)

\(\begin{aligned}
  s_{\text{r}}(t) &= R \sin\left(\omega_{\text{r}}(t) t\right) \\
                  &= R \sin\left(\omega_{\text{t}}(t-t_d) t\right) \\
                  &= R \sin\left(2 \pi f(t-t_d) t\right) \\
                  &= R \sin\left(2 \pi t \left( f_0 + (t-t_d) \frac{f_{\text{ramp}}}{t_{\text{ramp}}}
                    \right) \right)
\end{aligned}\)

Mixing the transmitted and received signals gives

\(\begin{aligned}
  m &= TR \sin\left(2 \pi t \left( f_0 + t \frac{f_{\text{ramp}}}{t_{\text{ramp}}}
                    \right) \right)
      \sin\left(2 \pi t \left( f_0 + (t-t_d) \frac{f_{\text{ramp}}}{t_{\text{ramp}}}
      \right) \right) \\
  \sin\theta\sin\phi &= \frac{1}{2} \left[\cos(\theta-\phi) -
                       \cos(\theta+\phi)\right] \\
  &\approx \frac{1}{2}\cos(\theta-\phi) && \texttt{$\cos(\theta+\phi)$ is too high to
    detect} \\
  m &\approx \frac{1}{2}TR\cos(2\pi\Delta f t)
\end{aligned}\)

We can compute the fourier transform of the mixer output to get the
frequency and then plug that into the range equation above to get the
distance to the target. The amplitude of the mixer output is related
to strength of the signal.

*** angle
The angle to the target is computed by beamforming
(i.e. phase-shifting one channel and summing both channels). See
hforsten's blog post for a description of this.

**** WRONG
To compute the angle to our target we can find the difference in
distance computed by each channel. Naively, we could try to do this by
using the same method as for the range calculation (i.e. compute the
difference in the difference frequencies). However, the difference
between the frequencies picked up by each receiver channel would be
too small to detect. To see this, solve the distance equation above
using a max distance difference of $\lambda/2$ (the distance between the
receiver antennas). Using a center frequency of 5.6GHz and a ramp
bandwidth of 600MHz, we get a maximum difference frequency of
200Hz. When we compute the [[id:9a522962-63bc-4569-b042-3b691549b8a6][fourier transform]], the frequency bins will
be spaced at 600kHz, which is way too crude to detect a 200Hz
difference frequency.

Instead, we can use the phase difference between the signals

** modules
*** fpga
At startup, configure the ADF4158. Then, perform 8 consecutive signal
ramps where each ramp delay is 2us and each duration is 0.512ms
(0.512ms to pick up all 1024 desired samples, plus a delay at the
beginning to avoid picking up any signals from the previous ramp,
corresponding to the max distance of 250m). The first ramp is for
antennas 1 and 2. The second is for antennas 3 and 4. The third and
fourth are for antennas 5 and 6, and 7 and 8, respectively. The fifth
ramp is for antennas 1 and 2 again. And so on until 8 ramps have
completed. The FIR polyphase decomposition filter is performed in
realtime during sampling. Additionally, since each antenna is recorded
twice and averaged, we store 4x 1024, 16-bit samples (i.e. 65kb
total).

**** state machine

\begin{latex}
\usetikzlibrary{positioning}
\usetikzlibrary{automata}
\begin{tikzpicture}[shorten >=1pt, auto]
  \node[state,initial] (adfconfig) {$\texttt{ADF config}$ \nodepart{lower} adf4158.enable=1};
  \node[state, node distance=4] (fir) [right=of adfconfig] {$\texttt{FIR}$};
  \node[state] (fifo) [right=of fir] {$\texttt{FIFO}$};
  \node[state] (fft) [right=of fifo] {$\texttt{FFT}$};
  \node[state] (ft245) [right=of fft] {$\texttt{FT245}$};

  \path[->] (adfconfig) edge node {adf\_config\_done} (fir);
\end{tikzpicture}
\end{latex}

*** frequency synthesizer
Each frequency step is 300kHz and lasts $0.5\si{\mu s}$. There are 1028 steps.

*** USB interface
A FT2232H chip is used to pass data between the host PC and FPGA. It
is used in 245 synchronous FIFO mode, which allows USB 2.0 high-speed
transfer rates (480Mb/s).

**** write transaction
A write transaction transmits data from the FPGA to the host PC.

***** timing details
The FPGA sends the FT2232H chip data for transmission using the 8-bit
ADBUS channel. The FT2232H registers this data and sends it over the
DM and DP USB data lines to the PC. FT2232H signals that it can
receive new data for transmission by driving the TXE# line low. When
the TXE# line is low, the FPGA can signal data for transmission by
driving the WR# line low and making the data available on the ADBUS
channel.

#+caption: FT2232H write transaction timing diagram. The setup time
#+caption: for WR# and ADBUS0 is between 1/2 and 1 clock period.

\begin{tikztimingtable}[%
  timing/dslope=0.1,
  timing/.style={x=5ex,y=2ex},
  x=5ex,
  timing/rowdist=3ex,
  timing/name/.style={font=\sffamily\scriptsize}
]
\busref{CLKOUT (60MHz)} & 25{c} \\
\busref{TXE\#}          & 3h 20l 2h \\
\busref{WR\#}           & 5h 18l 2h \\
\busref{ADBUS[7:0]}     & 5x 3d{0} 2d{1} 2d{2} 2d{3} 2d{4} 2d{5} 2d{6} 2d{7} 3x \\
\extracode
  \begin{pgfonlayer}{background}
    \begin{scope}[thick]
      \vertlines[blue]{3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5}
    \end{scope}
  \end{pgfonlayer}
\end{tikztimingtable}

**** read transaction
A read transaction sends data from the host PC to the FPGA.
*** receiver
*** digitization
The ADC reads both analog input channels simultaneously and
multiplexes the digital output on its 12-bit digital output
channel. Channel A data is output roughly in line with the clock at
high voltage and channel B is output roughly in line with the clock at
low voltage.

*** signal processing
The FPGA receives a 12-bit sample from each channel every 25ns (40MHz)
over a sweep duration of 1ms. Following the 1ms sweep, no data is
received for 2ms after which the process repeats.

**** big picture
There are 8 antennas multiplexed over 2 receiver channels. Data is
sampled at 40MHz with a twos complement precision of 12 bits. The data
is filtered in real time by a polyphase decomposition FIR filter that
removes signals over 1MHz (transition band from 0.95-1MHz). The
polyphase filter downsamples to 2MHz. The reason for filtering >1MHz
and downsampling to 2MHz is that once we downsample, our new sampling
frequency will be 2MHz and so we won't be able to detect any
frequencies above 1MHz. In fact, I believe any frequencies >1MHz will
show up (incorrectly) as frequencies below 1MHz (this is aliasing). We
want 1024 samples per channel (for the FFT) which, at 2MHz, means a
sweep duration of just over 0.5ms (set with the ADF4158
registers). There should then be a short delay of about 2us so that we
don't sample a signal transmitted in a previous sweep. We sample every
antenna twice and average over both sample sets, leaving 8 sequences
of 1024 12-bit data points stored in block ram. We then perform an FFT
on each of these 8 sequences. Then we perform an FFT across the angle
dimension.

**** filters
***** FIR
Use a polyphase decimation filter as described in Discrete-Time Signal
Processing page 182.

\begin{latex}
  \def\dff(#1){
  }
  \begin{circuitikz}
    \node at (0,-2) [twoport,draw,t=$\texttt{M}$] {};
  \end{circuitikz}
\end{latex}

***** kaiser window
After the FIR filter, a kaiser window is applied to the sample. This
also occurs in real-time on the sample and involves a simple pointwise
multiplication of each kaiser window coefficient by each sample.

**** downsampling
In order to make our data easier to process, we decimate it down to
2MHz. This leaves us with 2000 samples per channel per 3ms.

***** TODO correspondence b/e new frequency and max distance

**** fft
:PROPERTIES:
:ID:       9a522962-63bc-4569-b042-3b691549b8a6
:END:
After downsampling we perform a real FFT. By pipelining, we can
perform this in real-time as the signal is sampled. See the ZipCPU
tutorial on how to do this.

***** broad strokes
We sample each receiver channel at a frequency of 2MHz over 1ms. This
corresponds to 2000 samples per channel per sweep. We then take the
FFT of each channel, which yields 2000 frequency bins. Since frequency
resolution is equal to $\Delta f = f_s/N$, the frequency resolution is
1kHz. However, only the first half of the bins give real results
(critical sampling rate is twice nyquist frequency), so we are left
with 1000 freq bins of 1kHz resolution. Using the range equation we
can translate these frequency bins into distance bins, spaced 0.25m
apart. The max distance is 250m. The magnitude in each bin corresponds
to the strength of the signal at that distance.

Now we have 2 rows of 1000 elements each. If we add 98 rows of 1000
zeros each, and compute the fft for each column of 100, the first
column represents the signal strength between 0 and 0.25m for each
angle between -\pi and \pi radians?? The starting angle is the first row
and the ending angle is the last row. The last column is the 250m
distance for the same angles. Basically, we're left with the signal
strength at each angle and distance.

*** graphical rendering
The host PC takes the range/angle data from the FPGA and plots it
using matplotlib. See [[https://matplotlib.org/3.1.1/api/animation_api.html][this example]] and the [[https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.animation.FuncAnimation.html#matplotlib.animation.FuncAnimation][FuncAnimation]] documentation
for how to perform realtime plots with matplotlib. The host PC
simultaneously plots the realtime range and angle (using a polar plot,
where each point is a dB strength) and an incrementally updated (also
realtime) range-time plot. It provides the option to record both.
