#+title: Operation

* Overview
Broadly, the radar works by emitting a frequency ramp signal that
reflects off a remote object and is detected by a receiver. Because
the transmitted signal ramps at a known rate and travels through air
at the speed of light, the frequency difference between the
transmitted and received signals can be used to determine the distance
to the remote object.

** Note to the reader
A number of sections go into significant detail about various parts of
the radar. This information is not necessary to understand what the
radar does and broadly how it does it. Furthermore, it can even
distract from these goals. Still, I believe this information is
important, especially for people attempting to understand the radar in
detail and reproduce it themselves, and so I've kept it in. I've
placed the detailed information in subsections with links at the top
of those sections to the next high-level section. I hope that by
making it easy to skip these sections, this documentation will
simultaneously be useful to people who just want the overview and to
people who want to go into more detail.

* Physics
** Operating Principle
:PROPERTIES:
:ID:       285aab15-835c-464a-9a66-043078cfda28
:END:
The distance to a remote object is

\(\begin{aligned}
d &= \frac{c\Delta t}{2} \\
\end{aligned}\)

where \(\Delta t\) is the time delay between the transmitted and received
signals and \(c\) is the speed of light in air. The factor of \(2\)
accounts for the fact that the signal must travel the round-trip
distance. The transmitted and received signals at the input to the
mixer (see the [[id:012a28eb-d2bd-4cf4-8eed-832482c535cf][block diagram section]]) are shown in the plot below (as
pictured, these are sawtooth ramp signals with a time delay between
ramps).

\begin{latex}
\def\off{0.1}
\def\sep{0.3}
\begin{tikzpicture}[
declare function={
  f(\x) = and(\x >= 0, \x < 1) * \x
          + and(\x >= 1, \x < 3) * 0
          + and(\x >= 3, \x < 4) * (\x-3)
          + and(\x >= 4, \x < 6) * 0
          + and(\x >= 6, \x < 7) * (\x-6)
          + and(\x >= 7, \x < 9) * 0
          + and(\x >= 9, \x < 10) * (\x-9);
},
declare function={
  tx(\x) = f(x-\off)+\off;
},
declare function={
  rx(\x) = f(x-\off-\sep)+\off;
}
]
\begin{axis}[
  title=FMCW Tx - Rx Signal Delay,
  xlabel={$t$},
  ylabel={$f$},
  width=15cm, height=8cm,
  axis x line=bottom,
  axis y line=left,
  legend entries={tx, rx},
  legend style={
    fill=bg,
    draw=fgcolor
  },
  xmin=0, ymin=0,
  set layers=axis on top,
  xtick=\empty,
  ytick=\empty,
]
  \addplot[
    domain=0:7,
    samples=1000
  ]
  {tx(x)};
  \addplot[
    blue!20,
    domain=0:7,
    samples=1000
  ]
  {rx(x)};
  \draw[dashed] (axis cs:3.3,0.3) --++(axis cs:\sep,0);
  \draw ($(axis cs:3.3,0.3)+(axis cs:\sep/2,0)$) node[below,fill=bg] {$\Delta t$};
  \draw[dashed] (axis cs:3.3+\sep,0.3) --++(axis cs:0,\sep);
  \draw ($(axis cs:3.3+\sep,0.3)+(axis cs:0,\sep/2)$) node[right,fill=bg] {$\Delta f$};
\end{axis}
\end{tikzpicture}
\end{latex}

The ramp slope and duration are explicitly programmed. So, by finding
the frequency difference between the transmitted and received signals,
we can find the time difference and thus the distance:

\(\begin{aligned}
\Delta t &= \frac{\Delta f}{f_{\mathit{ramp}}} \\
d &= \frac{c \Delta f}{2 f_{\mathit{ramp}}} \\
\end{aligned}\)

To find the frequency difference we note that the transmitted signal
has the form (note that I've restricted \(t\) and \(t-\Delta t\) to be
within the bounds of a single ramp period)

\(\begin{aligned}
s_{t}(t) &= T \sin\left(\omega(t) t\right)
  && \text{$T$ is the transmission signal amplitude} \\
&= T \sin\left(2 \pi f(t) t\right) \\
&= T \sin\left(2 \pi t \left( f_0 + t \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}
  \right) \right) \\
\end{aligned}\)

The received signal is just a time-delayed copy of the transmitted
signal with a different amplitude. The amplitude changes because
energy is lost as the wave propogates through air. Energy is
proportional to the amplitude squared.

\(\begin{aligned}
s_r(t) &= \frac{R}{T} s_t(t-\Delta t) \\
s_r(t) &= R \sin\left(\omega(t-\Delta t) \left(t-\Delta t\right)\right) \\
&= R \sin\left(2 \pi f(t-\Delta t) \left(t-\Delta t\right)\right) \\
\end{aligned}\)

We can write this expression equivalently as

\(\begin{aligned}
s_r &= R \sin{\left(at - a\Delta t\right)} \\
\end{aligned}\)

where \(a=2\pi f(t-\Delta t)\). It's easy to see that this is
approximately equal to \(R \sin{\left(at\right)}\). Look back at our
distance equation in terms of the time delay. The max distance we'll
try to detect is \(250\si{m}\) (more on this later). Using that value,
we see that the maximum time delay is less than \(1.7\si{\mu s}\). In
contrast the value of \(t\) during a sweep ranges from
\(0-1\si{ms}\). So, for almost the entire ramp period, it's fair to
assume \(t>>\Delta t\). Using this approximation, the equation for our
received signal turns into

\(\begin{aligned}
s_r(t) &= R \sin\left(2 \pi t \left( f_0 + (t -\Delta t)
  \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}\right)\right) \\
\end{aligned}\)

The product of two sine functions can be equivalently represented as

\(\begin{aligned}
\sin{\theta} \sin{\phi} &=
  \frac{1}{2} \left[ \cos{\left(\theta - \phi\right)}
  - \cos{\left(\theta + \phi\right)} \right] \\
\end{aligned}\)

In other words, as a combination of a sinusoid of the frequency sum
and a sinusoid of the frequency difference. It's precisely the
frequency difference that we want. Moreover, the frequency sum will be
much higher than the frequency difference (about 4 orders of magnitude
in our case). As a result, the circuitry that we use to pick up the
difference frequency won't detect the sum frequency. Using this
knowledge, we see that if we multiply the transmitted and received
signals we get

\(\begin{aligned}
m &= TR \sin\left(2 \pi t \left( f_0 + t \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}
  \right) \right) \sin\left(2 \pi t \left( f_0 + (t -\Delta t) \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}
  \right) \right) \\
&\approx TR \sin{\left(2\pi t \Delta t
  \frac{f_{\mathit{ramp}}}{t_{\mathit{ramp}}}\right)} \\
&\approx TR \sin{\left(2\pi t \Delta f\right)} \\
\end{aligned}\)

So, using a Fourier transform on the mixer output will tell us the
frequency difference and thus the distance.

** TODO Maximum Range
:PROPERTIES:
:ID:       92c3042a-54ed-4ada-a099-bf8e2d27a729
:END:
It's possible to relate the range of a remote object to the power
received at a reception antenna using something known as the radar
range equation. I'll derive this equation since the derivation is
simple and facilitates conceptual understanding. Note that most of the
steps used in this derivation are identical to the derivation for the
well-known Friis transmission formula.

Start by imagining that our transmission antenna is isotropic. The
power density at some remote distance \(R\) is given by

\(\begin{aligned}
p_i &= \frac{P_T}{4\pi R^2}\\
\end{aligned}\)

where \(P_T\) is the transmitted power. The \(4\pi R^2\) comes from
the fact that the isotropic antenna by definition radiates power
equally in all directions and therefore the power density at some
distance is inversely related to the surface area of the sphere
centered at the transmission antenna. Now we replace the isotropic
antenna with an antenna with gain \(G_T\) in the direction of \(R\)
and the equation becomes

\(\begin{aligned}
p &= \frac{P_TG_T}{4\pi R^2}\\
\end{aligned}\)

At this distance \(R\) the transmitted signal reflects off a remote
object. The total reflected power is given by

\(\begin{aligned}
P_R &= p \sigma\\
&= \frac{P_TG_T\sigma}{4\pi R^2}\\
\end{aligned}\)

where \(\sigma\) is the cross-sectional area of the remote
object. Note that this is a bit of a simplification, since the total
reflected power will be dependent on several other factors such as the
material properties of the remote object and its shape. We lump all
these additional factors into the cross-sectional area, which is
therefore not generally exactly equal to the object's actual
cross-sectional area.

We now imagine the remote object simply as a remote isotropic antenna
with transmission power given by the reflected power shown
above. Therefore, we use the same method as the first step to find the
power density available at the reception antenna.

\(\begin{aligned}
p_R &= \left(\frac{P_TG_T\sigma}{4\pi R^2}\right)
  \left(\frac{1}{4\pi R^2}\right)\\
&= \frac{P_TG_T\sigma}{\left(4\pi R^2\right)^2}\\
\end{aligned}\)

To find the actual received power, we multiply the power density by
the reception antenna's effective aperture

\(\begin{aligned}
P_R &= \frac{P_TG_T\sigma}{\left(4\pi R^2\right)^2} A_e\\
A_e &= \frac{G_R \lambda^2}{4\pi}\\
P_R &= \frac{P_TG_TG_R\lambda^2\sigma}{\left(4\pi\right)^3 R^4}\\
\end{aligned}\)

This is the final result. We could equivalently rearrange our equation
in terms of the distance,

\(\begin{aligned}
R &= \sqrt[4]{\frac{P_T G_TG_R \lambda^2 \sigma}
  {P_R\left(4\pi\right)^3}} \\
\end{aligned}\)

In our case the transmission and reception antennas are identical, so
the equation simplifies to

\(\begin{aligned}
R &= \sqrt[4]{\frac{P_T G^2 \lambda^2 \sigma}
  {P_R\left(4\pi\right)^3}} \\
\end{aligned}\)

Therefore, to find the maximum range we need to find the minimum
detectable received power for a given remote cross-section.

For the wavelength, we use the center frequency of \(\SI{5.6}{GHz}\)
(\(\lambda = c/f_0\)), which corresponds to a wavelength of roughly
\(\SI{5.4}{cm}\). For the cross-sectional area we'll somewhat
arbitrarily take \(\SI{1}{m^2}\). It's worth noting for smaller
objects that the max distance is proportional to the square root of
one dimension of the remote object (assuming square objects). So,
cutting the dimension in half (\(0.5\times \SI{0.5}{m}\)) makes the
range roughly \(2/3\) of what we could expect previously.

\begin{tabularx}{13cm}{l l l l}
\toprule
Variable & Description & Value & Equation Units \\
\midrule
\(P_T\) & transmitted power & \(\SI{19.5}{dBm}\) & \(\SI{0.089}{W}\) \\
\(G\) & antenna gain & \(\SI{14}{dB}\) & \(28.9\) \\
\(\lambda\) & wavelength & \(\SI{5.4}{cm}\) & \(\SI{5.4e-2}{m}\) \\
\(\sigma\) & cross-sectional area & \(\SI{1}{m^2}\) & same \\
\(P_{R_{min}}\) & minimum-detectable received power &
  \(-\SI{115}{dBm}\) & \(\SI{3.16e-15}{W}\) \\
\bottomrule
\end{tabularx}

See [[id:4b5d444b-d558-4bf5-814d-b7e40facb4b0][the horn antenna section]] for how we found the transmission power
and antenna gain values.

The minimum-detectable power can be calculated by determining the
receiver noise and then setting some minimal signal-to-noise ratio
(SNR) above that value. We'll use an SNR of \(\SI{20}{dB}\). To find
the receiver noise, we start with the thermal noise and then add in
the noise contributed by all the receiver devices. The thermal noise
is given by

\(\begin{aligned}
P &= k_BTB\\
\end{aligned}\)

where \(k_B=\SI{1.38e-23}{m^2.kg.s^{-2}.K^{-1}}\) is Boltzmann's
constant, \(T=\SI{300}{K}\) is roughly room temperature and \(B\) is
the bandwidth. The bandwidth is the same as our frequency bin
resolution, which is given by

\(\begin{aligned}
B &= \frac{f_s}{N}\\
\end{aligned}\)

where \(f_s=\SI{2}{MHz}\) is the sampling frequency and \(N=1024\) is
the number of FFT samples. This gives a thermal noise power of

\(\begin{aligned}
P &= \SI{8.09e-18}{W}\\
&= -\SI{141}{dBm}\\
\end{aligned}\)

The [[id:ee12236d-727c-468d-b165-a1b6a7ab3450][receiver noise figure]] is \(\SI{6}{dB}\), which means the total
receiver noise power is

\(\begin{aligned}
P &= -\SI{135}{dBm}\\
\end{aligned}\)

The minimum-detectable power is the SNR above that value or

\(\begin{aligned}
P_{R_{min}} &= -\SI{115}{dBm}\\
\end{aligned}\)

Using these values in the radar range equation gives a maximum range
of about \(\SI{431}{m}\).

TODO the transmitted power (antenna efficiency) and antenna gain need
to be simulated, and are in general not in accordance with the values
presented in the original PDF.

** Minimum Range
The ADC supports a maximum voltage difference of
\(\pm\SI{1}{V}\). Outside of this, we get waveform clipping and
therefore distortion. We can work back from this value, using the
[[id:ee12236d-727c-468d-b165-a1b6a7ab3450][receiver gain]] to determine the maximum received power that avoids
distortion.

The IF amplifier has a gain of about \(\SI{23.5}{dB}\), which sets an
upper limit on the acceptable mixer output voltage of
\(\SI{67}{mV}\). We can convert this into an output power level using
the equation

\(\begin{aligned}
P &= \frac{V^2}{Z_{load}}\\
\end{aligned}\)

The mixer uses a differential output impedance of
\(Z_{load}=\SI{200}{\Omega}\), so the max output power is
\(P=\SI{2.23e-5}{W}=-\SI{16.5}{dBm}\). It's power conversion gain at
\(\SI{5.5}{GHz}\) is \(-\SI{3}{dB}\) and the collective LNA and RF
amplifier gain is \(\SI{25}{dB}\), so the max reception power that
avoids distortion is \(-\SI{44.5}{dBm}\). This corresponds to a
minimum distance of \(\SI{7.5}{m}\).

** TODO Angle Calculation
** TODO Additional Considerations
*** TODO Doppler Shift
See PDF.

* Block Diagram
:PROPERTIES:
:ID:       012a28eb-d2bd-4cf4-8eed-832482c535cf
:END:

\begin{circuitikz}[color=fgcolor]
\ctikzset{resistors/scale=0.4}
\ctikzset{blocks/scale=1.5}
% tx
\draw (6,0) node[coupler,scale=0.75](cpl){};
\gettikzxy{(cpl.3)}{\cplx}{\cply}
\draw (10,\cply) node[bareTXantenna](tx){\footnotesize Tx};
\draw (cpl.3) -- (tx.bottom);
\draw (cpl.1) --++(-0.5,0) to[R] ++(0,-1) node[tlground]{};
\draw ($(cpl.4)-(6,0)$) node[oscillator](fs){};
\draw (fs.east) to[amp,t=\footnotesize PA] (cpl.4);
\draw (fs.north) node[above]{\footnotesize Frequency};
\draw (fs.south) node[below]{\footnotesize Synthesizer};
% rx
\gettikzxy{(tx.center)}{\txx}{\txy}
\draw (\txx, -4) node[bareRXantenna,
  xscale=-1](rx){\scalebox{-1}[1]{\footnotesize Rx}};
\draw (rx.center) to[short] ++(-2,0)
  to[amp,t={\scalebox{-1}[-1]{\footnotesize LNA}}] ++(-2,0)
  to[amp,t={\scalebox{-1}[-1]{\footnotesize RF}}] ++(-2,0) coordinate (n1);
\draw (3, -4) node[mixer](mix){};
\draw (n1) to[short] (mix.3);
\draw (cpl.2) --++(1,0) --++(0,-2) -| (mix.4);
\draw (mix.1) --++(-0.5,0) to[lowpass] ++(-2,0)
  to[amp,t={\scalebox{-1}[-1]{\footnotesize IF}}]
  ++(-2,0) to[adc] ++(-2,0) --++(0,-2) coordinate (fpga) --++(0,-2)
  to[twoport,t=\footnotesize FIR] ++(2,0) to[twoport,t=$20\downarrow$] ++(2,0)
  to[twoport,t=\footnotesize window] ++(2,0) to[fft] ++(2,0) to[short,-o] ++(1,0)
  node[right] {\footnotesize PC};
\draw[dashed] ($(fpga)-(2,0)$) -- ($(fpga)+(8,0)$) node[below
  left]{\footnotesize FPGA} -- ($(fpga)+(8,-4)$);
\end{circuitikz}
#+caption: FMCW radar block diagram. Note that downsampling is
#+caption: actually performed as part of the FIR filter (not after)
#+caption: for efficiency reasons. Functionally, the result is
#+caption: identical.

A frequency synthesizer generates a sinusoidal signal that ramps in
frequency from \(5.3\) to \(\SI{5.9}{GHz}\) over a duration of
\(\SI{1}{ms}\). The signal is then amplified and most of the power is
sent to the transmission antenna. The remaining power is redirected to
a mixer for multiplication with the received signal. The light echo of
the transmitted signal is picked up by a reception antenna and
amplified with a low-noise amplifier followed by a high-frequency
amplifier. This amplified signal is mixed with the coupled portion of
the transmitted signal and output as a differential signal. The mixer
output is passed through a lowpass filter, which, together an
intermediate frequency amplifier passes and amplifies signals between
about \(\SI{10}{kHz}\) and \(\SI{1}{MHz}\). The signal is then
digitized at a sampling rate of \(\SI{40}{MHz}\), and passed to the
FPGA. The FPGA first uses a polyphase FIR filter to simultaneously
filter signals of frequency greater than \(\SI{1}{MHz}\) and
downsample the signal by a factor of 20 which reduces the
computational load for subsequent processing/transmission stages. The
signal is then multiplied by a kaiser window and finally transformed
into its frequency composition with a 1024-point FFT. The frequency
bins are then sent to a host PC for further processing and realtime
plotting.

* Transmitter
:PROPERTIES:
:ID:       2892ed74-7258-4776-ae3d-a5a417dda02c
:END:
The transmitter is responsible for generating a frequency ramp that is
transmitted through space via an antenna and coupled back into [[id:5b91918a-80ec-4cff-af24-e620558c087a][the
receiver]]. A frequency synthesizer (ADF4158) and VCO together generate
the ramp signal. A wilkinson power divider then splits the signal,
sending half the power to the power amplifier for transmission and the
other half back to the frequency synthesizer (see the [[id:8fa29eb6-36de-46e4-bcb7-93e611fa4a36][frequency
synthesizer section]]). The power amplifier amplifies the signal, most
of which is sent to the antenna for transmission. The remainder is
coupled back to the receiver with a coupler.

\begin{circuitikz}[color=fgcolor]
\ctikzset{multipoles/dipchip/width=2}
\ctikzset{resistors/scale=0.4}
\ctikzset{capacitors/scale=0.4}
\ctikzset{grounds/scale=0.6}
\draw (0,0) node[dipchip, num pins=10, hide numbers, no topmark,
  external pins width=0](fs){ADF4158};
\draw (fs.n) --++(0,0.5) node[vcc]{};
\draw (fs.s) --++(0,-0.5) node[ground]{};
\draw (fs.bpin 9) node[left, font=\tiny] {CP};
\draw (fs.bpin 7) node[left, font=\tiny] {$f_{\text{VCO}}$};
\draw (fs.w) node[right,font=\tiny]{$f_{\text{in}}$};
\draw (fs.w) to[short,-o] ++(-0.5,0);
\draw (fs.bpin 9) to[short,-*] ++(0.5,0) coordinate(cp) to[amp] ++(2,0)
  to[vco] ++(1,0) to[TL] ++(2,0) node[wilkinson,anchor=in](wilk){};
\draw (cp) to[C] ++(0,-0.75) node[tlground]{};
\draw (wilk.out2) to[tattenuator,label=\SI{5}{dB}] ++(2,0) to[amp,t=PA] ++(2,0)
  node[coupler,anchor=4](coupler){\SI{20}{dB}};
\draw (coupler.3) --++(1,0) node[bareTXantenna,anchor=center]{};
\draw (coupler.1) --++(-0.5,0) to[R] ++(0,-1) node[tlground]{};
\draw (coupler.2) --++(0.5,0) --++(0,-1) node[inputarrow,rotate=-90]{}
  node[below]{to receiver};
\draw (wilk.out1) --++(0.5,0) --++(0,-1)
  to[tattenuator,mirror,label=\SI{3}{dB}] ++(-7,0) |- (fs.bpin 7);
\end{circuitikz}
#+caption: Transmitter block diagram.

I included a single transmission line after the VCO to indicate that a
transmission line with characteristic impedance of \(\SI{50}{\Omega}\)
is required for each connection after the VCO (I've ommitted most of
them to save space). The [[id:f361bbcc-7225-453e-a107-3f4793e4dd4a][RF simulation section]] describes how to design
the microstrip transmission line. There are also several attenuators
used to keep input power within specification for the various
components.

** Frequency Synthesizer
:PROPERTIES:
:ID:       8fa29eb6-36de-46e4-bcb7-93e611fa4a36
:END:
Next high-level section: [[id:5b91918a-80ec-4cff-af24-e620558c087a][Receiver]]

The ADF4158 frequency synthesizer is based on a fractional-N PLL
(phase-locked loop) design. Chapter 13 of the Art of Electronics (3e)
provides an excellent description of how a PLL works. I explain the
relevant points here. The frequency synthesizer consists of a phase
detector and VCO (our VCO is an external component). It looks like
this (note that this diagram, along with the phase detector and VCO
diagrams are adapted from AoE).

\begin{circuitikz}[color=fgcolor]
\draw[->] (0,0) node[left]{$f_{\mathit{REF}}$} to[short,o-] ++(1,0)
  node[twoportshape,t=$\div r$,anchor=w](r){};
\draw[->] (r.e) --++(1,0) node[fourport,anchor=4,t=$\phi$-detector](det){};
\draw[->] ($(det.3)!0.5!(det.2)$) --++(1,0) coordinate(c1);
\draw (c1) node[vcoshape,anchor=w](vco){};
\draw[->] (vco.e) --++(2,0) node[right]{$f_{\mathit{VCO}}$};
\draw[->] (vco.e) ++(1,0) to[short,*-] ++(0,-1.5) --++(-1,0)
  node[twoportshape,t=$\div n$,anchor=e](n){};
\draw[->] (n.w) --++(-3.5,0) |- (det.1);
\end{circuitikz}

The phase detector, as the name suggests, outputs a voltage signal
which corresponds to the difference in phase between two input
frequencies. The VCO generates a frequency that is proportional to an
input voltage. Forget the frequency divider blocks for a minute. We'll
get back to them. \(f_{\mathit{REF}}\) is a reference frequency. In
our case this is a \(\SI{40}{MHz}\) clock frequency. Imagine that the
rising edge of \(f_{\mathit{REF}}\) occurs before the rising edge of
\(f_{\mathit{VCO}}\). In response, the phase detector increases it's
output voltage corresponding to the duration of time that
\(f_{\mathit{REF}}\) leads \(f_{\mathit{VCO}}\). This causes the VCO
output frequency to increase accordingly and the next edge of the VCO
output to occur sooner than the previous one. So, the phase gap
diminishes. The opposite occurs when \(f_{\mathit{REF}}\) lags behind
\(f_{\mathit{VCO}}\). The phase detector is detecting differences in
phase, not frequency. However, any differences in frequency will lead
to phase differences and thus the phase detector will cause the
frequency and phase of \(f_{\mathit{VCO}}\) to converge to that of
\(f_{\mathit{REF}}\).

All we've done so far is take \(f_{\mathit{REF}}\) and generate
another signal \(f_{\mathit{VCO}}\) with identical frequency and
phase, which isn't particularly useful. This is where the frequency
dividers come in. The R divider takes \(f_{\mathit{REF}}\) and outputs
a frequency \(f_{\mathit{REF}}/r\). The N divider does the same thing
for \(f_{\mathit{VCO}}\). So, what we're doing is setting

\(\begin{aligned}
\frac{f_{\mathit{VCO}}}{n} &= \frac{f_{\mathit{REF}}}{r}\\
f_{\mathit{VCO}} &= f_{\mathit{REF}} \left(\frac{n}{r}\right)\\
\end{aligned}\)

By setting \(n\) much larger than \(r\), we can generate an output
frequency that is much higher than the reference frequency. The
diagram above isn't completely accurate. What we've shown is an
integer-N frequency synthesizer, whereas the device we're using is a
fractional-N frequency synthesizer. The practical difference is that
our value of \(n\) can be non-integral and thus allows finer-grained
control of the output voltage.

*** TODO Phase Detector
TODO diagram below is deficient. Use the one from the wiki.

I've ommitted some important details about how the phase-detector
controls the voltage input to the VCO, which I'll discuss now.

Here's a possible implementation of a phase detector, taken from AoE.

\begin{circuitikz}[color=fgcolor]
\ctikzset{flipflops/scale=0.8}
\draw (0,0) node[flipflop D, add async SR](ff1){};
\draw (0,-3) node[flipflop D, add async SR](ff2){};
\draw ($(ff1.pin 1)+(-1,1)$) node[above]{$V_+$} to[short,o-*] ++(0,-1) coordinate(c1)
  --++(1,0);
\draw (c1) |- (ff2.pin 1);
\draw (ff1.pin 3) to[short,-o] ++(-2,0) node[left]{$f_{\mathit{REF}}$};
\draw (ff2.pin 3) to[short,-o] ++(-2,0) node[left]{$f_{\mathit{VCO}}$};
\draw (ff1.pin 6) to[short,-*] ++(2,0) coordinate(c2);
\draw[->] (c2) --++(4,0) coordinate(c3);
\draw (c3) node[isourceAMshape,anchor=s,rotate=-90](i1){};
\draw (ff2.pin 6) to[short,-*] ++(2,0) coordinate(c4);
\draw[->] (c4) --++(4,0) coordinate(c5);
\draw (c5) node[isourceAMshape,anchor=s,rotate=-90](i2){};
\draw ($(c2)!0.5!(c4)+(2,0)$) node[american and port](and){};
\draw (c2) |- (and.in 1);
\draw (c4) |- (and.in 2);
\draw (and.out) --++(0.5,0) --++(0,-4) --++(-0.5,0) node[american not
  port,anchor=in,xscale=-1](n1){};
\draw (n1.out) --++(-0.5,0) node[american not port,anchor=in,xscale=-1](n2){};
\draw (n2.out) --++(-0.5,0) coordinate(c7) -| (ff2.down);
\draw (c7) to[short,*-] ++(0,3.5) --++(-0.5,0) -| (ff1.down);
\draw (i1.w) --++(0,1) node[vcc]{};
\draw (i2.e) --++(0,-1) node[ground](gnd){};
\draw (i1.e) -- (i2.w);
\draw ($(i1.e)!0.5!(i2.w)$) to[short,*-*] ++(2,0) coordinate(c6)
  to[short,-o] ++(2,0) node[right]{$V_{\mathit{out}}$};
\gettikzxy{(gnd)}{\gndx}{\gndy}
\gettikzxy{(c6)}{\cx}{\cy}
\draw (c6) to[C] ++(0,\gndy-\cy) node[ground]{};
\end{circuitikz}

A high voltage level at the left input of each current source
activates the current source. Ignore the NOT buffers for now, I'll
discuss them in a minute. A positive voltage is constantly applied to
the D-input of each flip-flop. The outputs are set (brought to
digital 1) when the rising edge of the clock signal appears. Because
of the AND gate, both outputs are cleared (brought down to digital 0)
when both outputs are simultaneously set. Therefore, each flip-flop's
current source is only active for the duration of time when its
flip-flop is set and the other flip-flop is not set. The current
sources act as a charge pump. The top current source charges up the
capacitor and thus increases the voltage across it linearly with time
\(dV=(I/C)dt\). Similarly, the bottom current source decreases the
voltage across the capacitor. In other words, we are able to increase
or decrease the voltage to the VCO proportional to the phase lag
between the two signals.

Even if the purpose of the NOT gates is not immediately clear, it
should be easy to see that they are harmless. That is, the effect of
both current sources being active simultaneously is the same as both
being inactive since the bottom current source will sink all the
current from the top source and the voltage across the capacitor will
remain unchanged. The delay provided by the chained NOT gates is
necessary to ensure phase-locking when the phase difference between
the signals becomes very small. The reason for this is that the
transistor used to implement the current source has a parasitic
capacitance between the base and emitter, or gate and
source. Therefore the voltage difference between the terminals has a
nonzero rise time and so for very short activation periods, the
base-emitter or gate-source voltage will never rise enough to allow
the transistor to conduct, preventing the frequencies from ever
locking.

* Receiver
:PROPERTIES:
:ID:       5b91918a-80ec-4cff-af24-e620558c087a
:END:
The receiver's purpose is to capture the transmitted signal echo,
amplify it without introducing too much noise, mix it with the
transmitted signal down to an intermediate frequency, filter out
non-signal frequencies and then amplify it again for digitization by
the ADC. A simplified block diagram of the receiver hardware is shown
below. Note that this is just one of two receivers. The mixer and
differential amplifier support two separate differential signal pairs,
so that circuitry is shared between both receivers.

\begin{circuitikz}[color=fgcolor]
\ctikzset{inductors/scale=0.5}
\ctikzset{quadpoles/transformer/width=1}
\ctikzset{grounds/scale=0.5}
\ctikzset{amplifiers/plus={\tiny $+$}}
\ctikzset{amplifiers/minus={\tiny $-$}}
\draw (0,0) node[bareRXantenna](rx){Rx};
\draw (rx.bottom) --++(1,0) node[plain mono
  amp,anchor=in](lna){};
\draw ($(lna.center)-(0.15,0)$) node[]{\footnotesize LNA};
\draw (lna.out) --++(0.4,0) node[plain mono amp, anchor=in](rfamp){};
\draw ($(rfamp.center)-(0.15,0)$) node[]{\footnotesize RF};
\draw (rfamp.out) --++(0.4,0) node[transformer,anchor=A1](balun){};
\draw (balun.A2) node[ground]{};
\draw ($($(balun.B1)!0.5!(balun.B2)$)+(1,0)$) node[mixer,anchor=1](mix){};
\draw (balun.B1) --++(0.5,0) |- ($(mix.1)+(0,0.1)$) node[inputarrow]{};
\draw (balun.B2) --++(0.5,0) |- ($(mix.1)-(0,0.1)$) node[inputarrow]{};
\draw (mix.4) node[inputarrow,rotate=-90]{} --++(0,0.5)
  node[ocirc,fill=bgcolor,anchor=270]{} node[above=2pt]{\footnotesize
  coupled tx signal};
\draw ($(mix.3)+(3,0)$) node[fd op amp](if){};
\draw ($(if.center)-(0.3,0)$) node[]{\footnotesize IF};
\draw ($(mix.3)+(1,0)$) node[lowpassshape](bp){};
\draw ($(mix.3)+(0,0.1)$) -- ($(bp.west)+(0,0.1)$);
\draw ($(mix.3)-(0,0.1)$) -- ($(bp.west)-(0,0.1)$);
\draw ($(bp.east)+(0,0.1)$) --++(0.5,0) |- (if.-);
\draw ($(bp.east)-(0,0.1)$) --++(0.5,0) |- (if.+);
\draw (if.out +) node[ocirc,fill=bgcolor,anchor=0]
  node[right=2pt]{\footnotesize ADC +};
\draw (if.out -) node[ocirc,fill=bgcolor,anchor=0]
  node[right=2pt]{\footnotesize ADC -};
\end{circuitikz}

** Noise Figure
We use two amplifiers chained together immediately after the antenna
because it's critical that the first amplifier has low noise and high
gain. This decreases the [[id:92c3042a-54ed-4ada-a099-bf8e2d27a729][minimum detectable power]] and thus increases
the radar's range capability. The reason for this is a result of the
equation for the equivalent noise factors of two devices chained
together:

\(\begin{aligned}
F_{\mathit{NET}} &= F_1 + \frac{F_2-1}{G_1}\\
\end{aligned}\)

where \(F_1\) and \(F_2\) are the noise factors of the first and
second components, and \(G_1\) is the gain of the first component (as
an actual power ratio, not in dB). Therefore, we see that the greater
the gain of the first component, the more the total noise factor is
reduced. Here's a table of the relevant parameters for calculating the
total noise figure of the receiver. See the corresponding sections for
how these values were attained.

| Device | NF (dB) | G (dB) |
|--------+---------+--------|
| LNA    |       1 |     13 |
| RF Amp |     4.5 |     12 |
| Mixer  |      14 |     -3 |
| IF Amp |   10-20 |   23.5 |
|--------+---------+--------|
| Total  | 3.5-6.5 |   45.5 |

The IF amplifier noise figure was not given and has simply been
estimated. Additionally, I've included the filter gain as part of the
IF amplifier gain.

** Mixer
** Differential Amplifier
The differential amplifier's input circuitry is worth discussing
because it affects the amplifier's frequency response. There are 3
logical parts to this, shown in the schematic below. The pullup
resistors at the mixer output set the DC bias point of the output to
\(\SI{5}{V}\). This is followed by an LC lowpass filter, and then the
differential amplifier acts as a 2nd order active bandpass filter,
with roughly \(\SI{23}{dB}\) of gain. The DC blocking capacitors in
the active filter serve an additional purpose, which is to allow the
differential amplifier's input voltages to float down to the
acceptable input range. This is critical because the the \(\SI{5}{V}\)
bias point would be too high for the amplifier which has a supply
voltage of \(\SI{3.3}{V}\).

\begin{circuitikz}[color=fgcolor]
\ctikzset{tripoles/fd op amp/font=\footnotesize}
\draw (0,0) node[fd op amp](opamp){};
\gettikzxy{(opamp.+)}{\ampnix}{\ampniy}
\gettikzxy{(opamp.-)}{\ampix}{\ampiy}
\gettikzxy{(opamp.out +)}{\ampopx}{\ampopy}
\gettikzxy{(opamp.out -)}{\amponx}{\ampony}
\draw (opamp.-) --++(0,0.5) coordinate(ampi) to[R,l_=$\SI{549}{\Omega}$] ++(-2,0)
  to[C,l_=$\SI{10}{nF}$] ++(-2,0) to[short,-*] ++(-2,0) coordinate(cp)
  to[L,l_=$\SI{2.2}{\mu H}$,mirror] ++(-2,0) to[short,-*] ++(-2,0) coordinate(vbp)
  --++(-2,0) coordinate(vinp);
\gettikzxy{(vinp)}{\vinpx}{\vinpy}
\draw (vinp) to[sV,l_={\footnotesize mixer output}]
  ++($(0,\ampniy-\vinpy)-(0,0.5)$) coordinate(vinn);
\draw (opamp.+) --++(0,-0.5) coordinate(ampni) to[R=$\SI{549}{\Omega}$] ++(-2,0)
  to[C=$\SI{10}{nF}$] ++(-2,0) to[short,-*] ++(-2,0) coordinate(cn)
  to[L=$\SI{2.2}{\mu H}$,mirror] ++(-2,0) to[short,-*] ++(-2,0) coordinate(vbn) -- (vinn);
\draw[dashed] ($(vbp)+(1,3)$) -- ($(vbn)+(1,-3)$);
\draw ($($(vbp)!0.5!(vbn)$)+(1,0)$) node[left,align=center]{\footnotesize \vphantom{p} DC bias};
\draw ($($(vbp)!0.5!(vbn)$)+(1,0)$) node[right,align=center]{\footnotesize LC lowpass};
\draw[dashed] ($(cp)+(2,3)$) -- ($(cn)+(2,-3)$);
\draw ($($(cp)!0.5!(cn)$)+(2,0)$) node[right,align=center]{\footnotesize active bandpass};
\draw (vbp) to[R=$\SI{50}{\Omega}$,-*] ++(0,2) node[vcc](vcc1){$\SI{5}{V}$};
\draw (vcc1) to[C,l_=$\SI{100}{nF}$] ++(-2,0) node[ground]{};
\draw (vbn) to[R,l_=$\SI{50}{\Omega}$,-*] ++(0,-2) node[vee](vcc2){$\SI{5}{V}$};
\draw (vcc2) to[C=$\SI{100}{nF}$] ++(-2,0) node[ground]{};
\draw (cp) to[C=$\SI{2.2}{nF}$,*-*] (cn);
\draw (opamp.out +) --++(1,0) coordinate(voutp) to[short,*-o] ++(1,0)
  node[right]{$V_{out+}$};
\draw (opamp.out -) --++(1,0) coordinate(voutn) to[short,*-o] ++(1,0)
  node[right]{$V_{out-}$};
\gettikzxy{(voutp)}{\voutpx}{\voutpy}
\gettikzxy{(voutn)}{\voutnx}{\voutny}
\draw (voutp) --++(0,1) coordinate (a) to[R=$\SI{8.2}{k\Omega}$,*-*]
  ++(\ampix-\voutpx,0) coordinate(b) to[short,-*] (ampi);
\draw (a) --++(0,1) to[C=$\SI{10}{pF}$] ++(\ampix-\voutpx,0) -- (b);
\draw (voutn) --++(0,-1) coordinate (c) to[R=$\SI{8.2}{k\Omega}$,*-*]
  ++(\ampix-\voutpx,0) coordinate(d) to[short,-*] (ampni);
\draw (c) --++(0,-1) to[C=$\SI{10}{pF}$] ++(\ampix-\voutpx,0) -- (d);
\end{circuitikz}

The frequency response of this circuit is shown in the plots below.

#+begin_src python :results output silent :hidden
from skidl.pyspice import *
from libcircuit.spice import capacitor_equiv
import numpy as np

fname = "data/diff-amp-bp-filter.dat"
lib_search_paths[SPICE].append("/home/matt/src/spicelib")

rcm_val = 50e6
v5 = V(value=5)
v33 = V(value=3.3)
v15 = V(value=1.5)
vs = SINEV(amplitude=1)
# component declaration
rout = Part("pyspice", "R", value=1e9)
rload = Part("pyspice", "R", value=1e3)
lt = Part("pyspice", "L", value=2.2e-6)
lb = Part("pyspice", "L", value=2.2e-6)
cm = capacitor_equiv(value=2.2e-9)
ct = capacitor_equiv(value=10e-9)
cb = capacitor_equiv(value=10e-9)
rfbt = Part("pyspice", "R", value=8.2e3)
cfbt = Part("pyspice", "C", value=10e-12)
rfbb = Part("pyspice", "R", value=8.2e3)
cfbb = Part("pyspice", "C", value=10e-12)
ada4940 = Part("ADA4940", "ada4940")
rgt = Part("pyspice", "R", value=549)
rgb = Part("pyspice", "R", value=549)

shunt_top = Part("pyspice", "R", value=50)
shunt_bot = Part("pyspice", "R", value=50)
cbp_top = capacitor_equiv(value=100e-9)
cbp_bot = capacitor_equiv(value=100e-9)

# component connections
gnd += v33[2], v5[2], cbp_top[2], cbp_bot[2], v15[2]
vs[1] += shunt_top[2], lt[1], rout[1]
vs[2] += shunt_bot[2], lb[1], rout[2]
v5[1] += shunt_top[1], shunt_bot[1], cbp_top[1], cbp_bot[1]
v15[1] += ada4940["110"]
lt[2] += cm[1], ct[1]
lb[2] += cm[2], cb[1]
ct[2] += rgt[1]
cb[2] += rgb[1]
rgt[2] += rfbt[1], cfbt[1], ada4940["3A"]
rgb[2] += rfbb[1], cfbb[1], ada4940["9"]
ada4940["3B"] += rfbt[2], cfbt[2]
ada4940["9B"] += rfbb[2], cfbb[2]
ada4940["71B"] += rload[1]
ada4940["71"] += rload[2]
ada4940["99"] += v33[1]
ada4940["50"] += v33[2]

# generate netlist and waveforms
circ = generate_netlist(libs="/home/matt/src/spicelib")
sim = circ.simulator()
waveforms = sim.ac(
    variation="dec",
    number_of_points=100,
    start_frequency=1,
    stop_frequency=10e6,
)

freq = waveforms.frequency
vinp = waveforms[node(vs[1])]
vinn = waveforms[node(vs[2])]
voutp = waveforms[node(rload[1])]
voutn = waveforms[node(rload[2])]

with open(fname, "w") as f:
    f.write("{:10} {:10} {:10}\n".format("freq", "vratio", "phase"))
    for fr, vin, vout in zip(
        freq.as_ndarray(),
        vinp.as_ndarray() - vinn.as_ndarray(),
        voutp.as_ndarray() - voutn.as_ndarray(),
    ):
        arg = np.imag(vout / vin) / np.real(vout / vin)
        db = 20 * np.log10(abs(vout) / abs(vin))
        f.write("{:9.2f} {:9.5f} {:9.5f}\n".format(fr, db, np.arctan(arg),))
#+end_src

\begin{tikzpicture}
%
\begin{semilogxaxis}[
  title=IF Amplifier Input Filter,
  ylabel={G (dB)},
  xlabel={$f$},
  axis y line*=left,
]
  \addplot [] table[x=freq, y=vratio] {data/diff-amp-bp-filter.dat};
\end{semilogxaxis}
\begin{semilogxaxis}[
  ylabel={\textcolor{blue!20}{$\phi$}},
  axis y line*=right,
  ytick={-pi/4, 0, pi/4, pi/2},
  yticklabels={$-\pi/4$, $0$, $\pi/4$, $\pi/2$},
]
  \addplot [blue!20] table[x=freq, y=phase] {data/diff-amp-bp-filter.dat};
\end{semilogxaxis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{semilogxaxis}[
  title=IF Amplifier Input Filter (Passband),
  ylabel={G (dB)},
  xlabel={$f$},
  axis y line*=left,
  grid=both,
  xmin=30e3, xmax=1e6,
]
  \addplot [] table[x=freq, y=vratio] {data/diff-amp-bp-filter.dat};
\end{semilogxaxis}
\begin{semilogxaxis}[
  ylabel={\textcolor{blue!20}{$\phi$}},
  axis y line*=right,
  xmin=30e3, xmax=1e6,
  xticklabels=\empty,
  xtick=\empty,
  ytick={-pi/8, 0, pi/8, pi/4},
  yticklabels={$-\pi/8$, $0$, $\pi/8$, $\pi/4$},
]
  \addplot [blue!20] table[x=freq, y=phase] {data/diff-amp-bp-filter.dat};
\end{semilogxaxis}
\end{tikzpicture}

* Digitization and Data Processing
* USB Interface
:PROPERTIES:
:ID:       cecb79d6-db88-42bb-90b1-c61545fa00fc
:END:
* FPGA
:PROPERTIES:
:ID:       6d0ccb21-c85b-417a-961e-5bbfb78717d9
:END:
A top-level block diagram of the FPGA logic is shown below. The data
output by the ADC (see [[id:5b91918a-80ec-4cff-af24-e620558c087a][receiver]]) enters the FPGA and is demultiplexed
into channels A and B, corresponding to the two receivers. For a
simple range detection (i.e. ignoring incident angle), channel B is
dropped. Channel A is input to a [[id:feb22339-7b6b-495b-9432-3999c179b164][polyphase FIR decimation filter]] that
filters out frequencies above 1MHz and downsamples from 40MHz to
2MHz. The FIR output is then passed through a [[id:0a0cea3d-b2d1-4b95-bc76-719e0f499fec][kaiser window]], followed
by an asynchronous FIFO, which is read by the [[id:5535c7fa-c614-4b3e-ac41-efa5581223b6][FFT module]] at 40MHz. The
FFT real and imaginary outputs are time-multiplexed and written to
another asynchronous FIFO.

When the bitstream is fully loaded onto the FPGA, the FPGA control
logic immediately begins configuring the [[id:a0e92e3e-3444-4956-8c07-b4d14d1f2489][ADF4158 frequency
synthesizer]], which is enabled at the end of configuration. The
frequency synthesizer emits a voltage pulse on the muxout line at the
end of each frequency ramp. The onboard ADF4158 control logic counts
the appropriate delay and turns this into a ramp start signal that the
control unit (CU) uses to synchronize the data processing pipeline to
the ramp period. The FIR filter and kaiser window are enabled
simultaneously (ignoring a small delay for the FIR latency). Once the
FIFO is full, the FIR filter and kaiser windows are disabled and the
FFT is enabled. The data processing pipeline waits for the next ramp
start signal before recommencing. If the FT245 write FIFO is not empty
when the ramp start is signaled (more on this in a minute), the CU
delays another full ramp period and then tries again.

The PC (see [[id:a434cb1f-9f49-407b-aa58-2d561982d98d][the software section]]) is able to request the data it wants
from the FPGA. The FT245 module (which is an interface to the FT2232H
USB interface chip, see [[id:cecb79d6-db88-42bb-90b1-c61545fa00fc][USB interface]]) reads a command from the PC and
selects the corresponding step in the data processing pipeline to send
to the PC. Writing from the FPGA to PC is also controlled by the same
FT245 module. The PC has the option of receiving the raw ADC data
(both channels), the FIR filtered output, the kaiser window output, or
the fully-processed FFT output.

\begin{circuitikz}[color=fgcolor]
\ctikzset{multipoles/dipchip/width=6/5}
\tikzset{demux/.style={muxdemux, muxdemux def={Lh=1, Rh=2, NL=1, NB=0,
  NR=2, w=1}}}
\tikzset{smallMux/.style={muxdemux, muxdemux def={Lh=2, Rh=1, NL=2, NB=0,
  NR=1, w=1}}}
\tikzset{largeMux/.style={muxdemux, muxdemux def={Lh=4, Rh=2, NL=4, NB=0,
  NT=1, NR=1, w=1.5}}}
\def\block{node[dipchip, num pins=6, hide numbers, no topmark, external
  pins width=0,anchor=bpin 2]}
\def\blockTop{node[dipchip, num pins=6, hide numbers, no topmark, external
  pins width=0,anchor=n]}
\def\smallBlock{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=n]}
\def\smallBlockRight{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=bpin 2]}
\def\smallBlockLeft{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=bpin 1]}
\def\smallBlockBottom{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=s]}
\def\pcblock{node[dipchip, num pins=4, hide numbers, no topmark, external
  pins width=0,anchor=bpin 3]}
%% ADF4158 and control
\draw (0,0) node[left]{\footnotesize muxout} --++(2,0)
  node[inputarrow]{} \block(adf){\footnotesize ADF4158};
\draw (adf.bpin 5) to[short] ++(1.5,0) node[inputarrow]{}
  \block(control){\footnotesize CU};
%% ADC
\draw (0,-3) node[left]{\footnotesize adc\_d\_i} --++(2,0)
  node[inputarrow]{} node[demux, anchor=west](demux){};
%% processing blocks
\draw ($(adf.bpin 5)!0.5!(control.bpin 2)$) node[above]{\tiny ramp start};
\draw (control.bpin 4) -|++(1,-1) node[inputarrow,rotate=-90]{} coordinate (b);
\draw (b) node[below]{\tiny en} \blockTop(fir){\footnotesize FIR};
\draw (fir.bpin 5) --++(1,0) node[inputarrow]{}
  \block(kaiser){\footnotesize kaiser};
\draw ($(fir.bpin 5)!0.5!(kaiser.bpin 2)$) node[above]{\tiny
  2MHz} coordinate(firOut);
\draw (control.bpin 5) -| (kaiser.n) node[inputarrow,rotate=-90]{}
  node[below]{\tiny en};
\draw (kaiser.bpin 5) --++(1,0) node[inputarrow]{}
  \block(fifo){\footnotesize FIFO};
\draw ($(kaiser.bpin 5)!0.5!(fifo.bpin 2)$) coordinate(kaiserOut);
\draw (fifo.bpin 5) --++(1,0) node[inputarrow]{}
  \block(fft){\footnotesize FFT};
\draw ($(fifo.bpin 5)!0.5!(fft.bpin 2)$) node[above]{\tiny 40MHz};
\draw (control.bpin 6) -| (fft.n) node[inputarrow,rotate=-90]{}
  node[below]{\tiny en};
%% ADC to FIR
\draw (demux.rpin 1) node[above right]{\tiny chA} --++(1,0) |-
  (fir.bpin 2) node[inputarrow]{};
\draw (demux.rpin 2) node[right]{\tiny chB} node[ocirc,fill=bg]{};
%% data output
\draw ($(fft.s)-(0.28,0)$) node[above]{\tiny Im}
  --++(0,-0.5) coordinate (fftIm);
\draw ($(fft.s)+(0.28,0)$) node[above]{\tiny Re}
  --++(0,-0.5) coordinate (fftRe);
\draw (fftIm) node[smallMux,anchor=lpin 2,rotate=-90](smallMux){};
\draw (smallMux.rpin 1) --++(0,-0.3) node[left]{\tiny 80MHz}
  --++(0,-0.7) coordinate(c) \smallBlock(ellipsisBlock){\tiny
  \textellipsis};
\draw (ellipsisBlock.s) \smallBlock(imblock){\tiny Im};
\draw (imblock.s) \smallBlock(reblock){\tiny Re};
\draw (reblock.s) --++(0,-1) node[inputarrow,rotate=-90]{}
  \blockTop(fifob){\footnotesize FIFO};
\gettikzxy{(control.bpin 5)}{\controlRightX}{\controlRightY}
\gettikzxy{(fifob.bpin 2)}{\fifoBLeftX}{\fifoBLeftY}
\draw (fifob.bpin 2) node[above left]{\tiny 40MHz}
  --++(\controlRightX-\fifoBLeftX,0) node[largeMux,anchor=lpin
  4,xscale=-1](largemux){};
\gettikzxy{(adf.bpin 5)}{\adfRightX}{\adfRightY}
\gettikzxy{(largemux.rpin 1)}{\largemuxOutX}{\largemuxOutY}
\draw (largemux.rpin 1) --++(\adfRightX-\largemuxOutX,0)
  node[inputarrow,rotate=180]{} \smallBlockRight(wrfifo){\tiny write
  FIFO};
\draw (wrfifo.n) \smallBlockBottom(rdfifo){\tiny read FIFO};
\draw (rdfifo.n) node[above]{\footnotesize FT245};
\draw (rdfifo.bpin 2) --++(0.25,0) |-++(0.25,1.5) node[inputarrow]{}
  \smallBlockLeft(controlb){\footnotesize control};
\draw (controlb.bpin 2) -| (largemux.tpin 1) node[left]{\tiny
  OP STATE};
\draw (firOut) to[short,*-] ++(0,-1) |- (largemux.lpin 2);
\draw (kaiserOut) to[short,*-] ++(0,-1) |- (largemux.lpin 3);
\draw (1.5,-3) node[above]{\tiny 40MHz} to[short,*-] ++(0,-1)
  --++(6,0) |- (largemux.lpin 1);
\gettikzxy{(wrfifo.bpin 1)}{\wrfifoLeftX}{\wrfifoLeftY}
\draw (wrfifo.bpin 1) --++(-\wrfifoLeftX,0)
  node[inputarrow,rotate=180]{} \pcblock(pc){\footnotesize PC};
\draw (pc.bpin 4) -- (rdfifo.bpin 1) node[inputarrow]{};
%% PCB and PC demarcation
\draw[dashed] (0.5,1) node[below left]{\footnotesize PCB} |- (-1,-4);
\draw[dashed] (-1,-7) -| (0.5,-11);
\end{circuitikz}

** FIR Polyphase Decimation Filter
:PROPERTIES:
:ID:       feb22339-7b6b-495b-9432-3999c179b164
:END:
The FIR polyphase decimation filter has two functions: it filters out
signals above 1MHz and downsamples the data to 2MHz. 1MHz corresponds
to the maximum distance we're interested in detecting and the new 2MHz
sampling rate ensures we stay above the Nyquist rate to avoid
aliasing.

We can't downsample before filtering because that would alias signals
above 1MHz into our filtered output. However, filtering before
downsampling would require us to perform filtering on the full 40MHz
input, which is inefficient because most of this data would be
immediately discarded. Fortunately, we can use a polyphase decimation
filter to get the best of both worlds (see the [[id:491617b7-7ba2-4a76-9a68-89ff7f8608b9][implementation section]]
for details).

*** Implementation
:PROPERTIES:
:ID:       491617b7-7ba2-4a76-9a68-89ff7f8608b9
:END:
Next high-level section: [[id:0a0cea3d-b2d1-4b95-bc76-719e0f499fec][Kaiser Window]]

In order for our polyphase decimation FIR filter to work it needs to
produce results identical what we'd get if we first filtered our
signal and then downsampled. Our input signal arrives at 40MHz and
then we downsample to 2MHz by only keeping every 20th signal.

Start with the normal equation for an FIR filter:

\(\begin{aligned}
  y[n] &= (h*x)(n) = \sum_{k=0}^{N-1} h[k] x[n-k]\\
\end{aligned}\)

\(x[n]=x[0],x[1],\ldots\) is our input sequence where \(x[0]\) is the
first sample, etc. \(h[n]\) is the filter's impulse response (I use a
120-tap filter) which we precompute in software (I've used scipy, see
the code for details). We need 1024 post-downsampling samples for the
FFT. Expanding this out, we get

\(\begin{aligned}
  y[0] &= h[0]x[0] \\
  y[1] &= h[0]x[1] + h[1]x[0] \\
  y[2] &= h[0]x[2] + h[1]x[1] + h[2]x[0] \\
  &\ldots \\
  y[20] &= h[0]x[20] + h[1]x[19] + \ldots + h[20]x[0] \\
  &\ldots \\
  y[119] &= h[0]x[119] + h[1]x[118] + \ldots + h[119]x[0] \\
  y[120] &= h[0]x[120] + h[1]x[119] + \ldots + h[119]x[1] \\
  &\ldots \\
\end{aligned}\)

The pattern is easy to see, but let me draw your attention to the last
term of the last equation in case you rushed through it. Specifically,
once the number of coefficients becomes less than the historical
number of inputs, we drop the oldest input each time we add a new
input. None of this is different than a normal FIR filter yet.

The difference comes in noticing that the only results we want after
filtering and downsampling are

\(\begin{aligned}
  y[0] &= h[0]x[0] \\
  y[20] &= h[0]x[20] + h[1]x[19] + \ldots + h[20]x[0] \\
  y[40] &= h[0]x[40] + h[1]x[39] + \ldots + h[40]x[0] \\
  y[60] &= h[0]x[60] + h[1]x[59] + \ldots + h[60]x[0] \\
  &\ldots \\
  y[120] &= h[0]x[120] + h[1]x[119] + \ldots + h[119]x[1] \\
  &\ldots \\
\end{aligned}\)

And these should arrive at the output at a frequency of 2MHz.

We need to figure out how to compute this directly; i.e. without
filtering and then downsampling as we did above. The schematic below
implements this.

\begin{circuitikz}[color=fgcolor]
\ctikzset{flipflops/scale=0.5}
\ctikzset{blocks/scale=0.3}
\ctikzset{multipoles/flipflop/font=\scriptsize}
\tikzset{flipflop ff/.style={flipflop,
  flipflop def={t1=D, c3=1, t6=Q}}
}
\def\bank#1#2#3#4#5#6#7#8{%
  \draw #1 node[flipflop ff, anchor=pin 1](ff0){};
  \draw (ff0.pin 3) --++(-0.25,0) node[left]{\tiny $\SI{2}{MHz}$};
  \draw ($(ff0.pin 1)-(0.25,0)$) coordinate(ffout0);
  \draw (ffout0) --++(0,0.5) node[mixer,anchor=2](mix0){};
  \draw (mix0.1) --++(-0.25,0) node[left]{\tiny #2};
  \draw (ff0.pin 6) --++(0.25,0) coordinate(ffout1)
    --++(0.25,0) node[flipflop ff, anchor=pin 1](ff){};
  \draw (ffout1) --++(0,0.5) node[mixer,anchor=2](mix){};
  \draw (mix.1) --++(-0.25,0) node[left]{\tiny #3};
  \draw (mix.3) -|++(0.1,0.5) node[adder,anchor=2](add){};
  \draw (mix0.3) --++(0.1,0) |-(add.1);
  \draw (ff0.pin 3) --++(0,-0.5) -| (ff.pin 3);
  \foreach \coeff in {#4, #5, #6} {
    \gettikzxy{(ff.pin 3)}{\fflastclkx}{\fflastclky}
    \draw (ff.pin 6) --++(0.25,0) coordinate(ffout)
    --++(0.25,0) node[flipflop ff, anchor=pin 1](ff){};
    \draw (ffout) --++(0,0.5) node[mixer,anchor=2](mix){};
    \draw (mix.1) --++(-0.25,0) node[left]{\tiny \coeff};
    \gettikzxy{(add.3)}{\addlastx}{\addlasty}
    \draw (mix.3) -|++(0.1,0.5) node[adder,anchor=2](add){};
    \draw (\addlastx,\addlasty) -- (add.1);
    \draw ($(\fflastclkx,\fflastclky)-(0,0.5)$) -| (ff.pin 3);
  }
  \draw (ff.pin 6) --++(0.25,0) node[mixer,anchor=1](mix){};
  \draw (mix.4) --++(0,0.25) node[above]{\tiny #7};
  \draw (mix.3) --++(0.25,0) node[adder,anchor=1](addnew){};
  \draw (add.3) -| (addnew.4);
  \draw (addnew.3) coordinate(#8);
}
\draw (0,0) node[left]{$x[n]$} --++(1,0) coordinate(a)
--++(3,0) coordinate(b);
\bank{(b)}{$h[0]$}{$h[20]$}{$h[40]$}{$h[60]$}{$h[80]$}{$h[100]$}{outa};
\draw (a) |-++(0.25,-1.5) node[flipflop ff, anchor=pin 1](ff1){};
\draw (ff1.pin 3) --++(-1,0) node[left]{\tiny $\SI{40}{MHz}$};
\draw (ff1.pin 6) -|++(0.25,-2.5) coordinate(c);
\gettikzxy{(a)}{\ax}{\ay}
\gettikzxy{(b)}{\bx}{\by}
\gettikzxy{(c)}{\cx}{\cy}
\draw (c) --++(\bx-\cx,0) coordinate(d);
\bank{(d)}{$h[1]$}{$h[21]$}{$h[41]$}{$h[61]$}{$h[81]$}{$h[101]$}{outb};
\draw (c) --++(\ax-\cx,0) |-++(0.25,-1.5) node[flipflop ff, anchor=pin 1](ff2){};
\draw (ff2.pin 6) -|++(0.25,-2.5) coordinate(d);
\draw (d) --++(\bx-\cx,0) coordinate(e);
\bank{(e)}{$h[2]$}{$h[22]$}{$h[42]$}{$h[62]$}{$h[82]$}{$h[102]$}{outc};
\draw ($(ff1.pin 3)-(0.75,0)$) |- (ff2.pin 3);
\draw ($(ff2.pin 3)-(0.75,0)$) --++(0,-3) coordinate(f);
\gettikzxy{(d)}{\dx}{\dy}
\gettikzxy{(f)}{\fx}{\fy}
\draw (d) --++(\ax-\cx,0) --++(0,\fy-\dy) coordinate(g);
\draw ($(f)+(0.25,-0.5)$) node[]{\Huge $\ldots$};
\draw ($(g)-(0,1)$) |-++(0.25,-1.5) node[flipflop ff, anchor=pin 1](ff3){};
\draw ($(f)-(0,1)$) |-(ff3.pin 3);
\draw (ff3.pin 6) -|++(0.25,-2.5) coordinate(h);
\draw (h) --++(\bx-\cx,0) coordinate(i);
\bank{(i)}{$h[19]$}{$h[39]$}{$h[59]$}{$h[79]$}{$h[99]$}{$h[119]$}{outd};
\draw (outc) --++(2,0) node[dipchip, num pins=10, hide numbers, no
topmark, external pins width=0, anchor=bpin 3](adder){\Huge $+$};
\draw (outa) --++(1,0) |- (adder.bpin 1);
\draw (outb) --++(0.5,0) |- (adder.bpin 2);
\draw (adder.bpin 4) node[left]{$\ldots$};
\draw (outd) --++(0.5,0) |- (adder.bpin 5);
\draw (adder.bpin 8) --++(1,0) node[right]{$y[n]$};
\end{circuitikz}

The leftmost (vertically stacked) flip-flops make up a shift register
clocked at 40MHz. Each horizontal set of flip flops make up another
shift register, all clocked at 2MHz. The first input, \(x[0]\), will
be registered in the leftmost flip-flop of the top 2MHz shift
register. It will also be multiplied by \(h[0]\) and pass to the
output so that the first output value is \(y[0]=h[0]x[0]\) as
expected. The horizontal shift registers will not register another
input until the new input is \(x[20]\) and the vertical shift register
has values, \(x[19]\), \(x[18]\), \(\ldots\) and \(x[1]\), proceeding
from the top flip flop down. The corresponding output will be the sum
of \(h[0]x[20]\), \(h[1]x[19]\), \(h[2]x[18]\), \(\ldots\),
\(h[19]x[1]\), and \(h[20]x[0]\), which comes from the second
multiplier in the top shift register. It's easy to follow this pattern
and see that we get the intended output.

You may have observed that if we were to follow this diagram
precisely, we would need 120 multiplication blocks. That's
significantly more than the 45 DSP slices we get on our XC7A15T
FPGA. Luckily, we can deviate from the diagram and use our multiplies
much more efficiently. The key to this is to notice that DSP slices
can be clocked at a much higher frequency (typically several hundred
MHz) than the frequency we're using them at (2MHz). So, by
time-multiplexing DSP slices we can use significantly fewer physical
multiply blocks than in the naive implementation. Theoretically, we
should be able to use a single DSP element for all 120
multiplies. However, I've used 10 (each DSP element is shared by 2
filter banks), which simplifies the control logic. Additionally, by
using the multiplies more efficiently, the number of DSP elements is
no longer the resource-limiting factor. Instead, we're limited by the
number of flip-flops needed for the filter banks. In the current
implementation we have 120 filter bank memory elements that must each
store 12 bits, which means 1440 flip-flops. We have room to increase
this, but a 120-tap filter should be good enough. We could potentially
cut down on resources by replacing the filter bank flip-flops with
time-multiplexed block RAM in much the same way as the DSP
slices. However, this is not that easy because the output of every
filter bank memory element must be available at every 2MHz clock
pulse. Since we're already time-multiplexing the multiplies, we would
need to synchronize this with the RAM access. This is worth pursuing
if we run low on resources or need a better filter. Otherwise, the
current implementation should be sufficient for our needs.

** Kaiser Window
:PROPERTIES:
:ID:       0a0cea3d-b2d1-4b95-bc76-719e0f499fec
:END:
Windowing is used to reduce spectral leakage in our input signal
before performing an FFT on that signal. This section's subsections
describe [[id:d6b994f0-0684-404f-ba91-36ab68e4f6b1][what spectral leakage is]], [[id:f4a4c107-8006-4ed5-ab5c-5ecfedc450e1][how windowing helps to reduce it]],
and [[id:b3437309-97a4-47fc-b51f-9ac373300bf8][how to implement a window function on an FPGA]].

*** Spectral Leakage
:PROPERTIES:
:ID:       d6b994f0-0684-404f-ba91-36ab68e4f6b1
:END:
Next high-level section: [[id:5535c7fa-c614-4b3e-ac41-efa5581223b6][FFT]]

Spectral leakage occurs when an operation introduces frequencies into
a signal that were not present in the original signal. In our case,
spectral leakage is due to an implicit rectangular window performed on
our input by taking a finite-duration subsample of the original
signal. The plots below illustrate this effect for a single-frequency
sinusoidal input.

\begin{tikzpicture}
\def\freq{4.5}
\begin{groupplot}[
  group style={group size=1 by 3, vertical sep=1cm},
  axis x line=middle,
  axis y line=middle,
  height=4cm, width=10cm,
  xmin=-2*pi, xmax=2*pi,
  ymin=-1.5, ymax=1.5,
  xtick=\empty, xticklabels=\empty,
  ytick=\empty, yticklabels=\empty,
  xticklabel style={
    fill=bg
  },
]
  \nextgroupplot[
    title={\footnotesize Pure Sine Wave Input},
    xlabel={$t$},
    ylabel={$A$},
  ]
  \addplot[
    domain=-2*pi:2*pi,
    samples=1000,
    blue!20,
  ] {sin(deg(\freq*x))};

  \nextgroupplot[
    title={\footnotesize Implicit Rectangular Window},
  ]
  \addplot[
    domain=-pi:pi,
    samples=100,
    blue!20,
  ] {1};
  \addplot[
    domain=-2*pi:-pi,
    samples=100,
    blue!20,
  ] {0};
  \addplot[
    domain=pi:2*pi,
    samples=100,
    blue!20,
  ] {0};
  \draw[blue!20] (axis cs:(-pi,0) -- (-pi,1));
  \draw[blue!20] (axis cs:(pi,0) -- (pi,1));

  \nextgroupplot[
    title={\footnotesize Actual Input},
  ]
  \addplot[
    domain=-pi:pi,
    samples=500,
    blue!20,
  ] {sin(deg(\freq*x))};
  \addplot[
    domain=-2*pi:-pi,
    samples=100,
    blue!20,
  ] {0};
  \addplot[
    domain=pi:2*pi,
    samples=100,
    blue!20,
  ] {0};
  \draw[blue!20] (axis cs:(-pi,0) -- (-pi,sin(deg(\freq*-pi))));
  \draw[blue!20] (axis cs:(pi,0) -- (pi,sin(deg(\freq*pi))));
\end{groupplot}
\end{tikzpicture}

We see that the beginning and end of the sample sequence jump from
zero to some nonzero value. This corresponds to a range of frequency
components not present in the original signal but that we can detect
in the FFT output. Note that we could eliminate the spectral leakage
by windowing an exact integral number of periods of the input
signal. But, we can't rely on being able to do this, especially for
signals composed of multiple frequencies.

Let's use some example sample sequences to illustrate the various
effects spectral leakage can have.

Start with a simple sinusoid with frequency 1Hz. We'll always ensure
the sampling rate is at or above the Nyquist rate to avoid aliasing.

The first plot shows the input sample sequence.

#+header: :file data/spectral-leakage-ex1-seq.dat
#+header: :session spectral-leakage
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
ts = f / 3
fs = 1 / ts
t = np.arange(0, 5.1 * f, step=ts)
s = np.sin(2*np.pi*f*t)
print("time signal")
for x, y in zip(t, s):
    print("{:.5f} {:.5f}".format(x, y))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$t$},
  axis x line=middle,
  axis y line=middle,
  set layers=axis on top,
  xticklabel style={
    fill=bg
  }
]
  \addplot[
    domain=0:5,
    samples=500,
  ] {sin(deg(2*pi*x))};
  \addplot[
    only marks,
    mark options={blue!50,scale=0.75},
  ] table[x=time, y=signal] {data/spectral-leakage-ex1-seq.dat};
\end{axis}
\end{tikzpicture}

This yields the fourier transform output

#+header: :file data/spectral-leakage-ex1-fft.dat
#+header: :session spectral-leakage
#+begin_src python :results output silent file :hidden
fft = np.absolute(np.fft.rfft(s))
fft /= np.sum(fft)
bins = np.fft.rfftfreq(len(t))
print("bin fft")
for x, y in zip(bins, fft):
    print("{:.5f} {:.5f}".format(x * fs, y))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$f$},
  set layers=axis on top,
  xtick=data,
  xticklabel style={
    font=\footnotesize,
    fill=bg
  },
  ybar,
]
  \addplot[fill=blue!75] table[x=bin, y=fft] {data/spectral-leakage-ex1-fft.dat};
\end{axis}
\end{tikzpicture}

If the FFT were correctly representing the true input signal, the
entire spectral content would be within the 0.94Hz frequency bin (this
includes the 1Hz frequency). The fact that it also registers spectral
content at other frequencies is the spectral leakage.

If we change the phase of the input signal, the output will change as
well, which shows the dependence of our output on uncontrolled
variations in the input.

#+header: :file data/spectral-leakage-ex2-seq.dat
#+header: :session spectral-leakage2
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
ts = f / 3
fs = 1 / ts
t = np.arange(0, 5.1 * f, step=ts)
s = np.sin(2*np.pi*f*t + (f/2))
print("time signal")
for x, y in zip(t, s):
    print("{:.5f} {:.5f}".format(x, y))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$t$},
  axis x line=middle,
  axis y line=middle,
  set layers=axis on top,
  xticklabel style={
    fill=bg
  }
]
  \addplot[
    domain=0:5,
    samples=500,
  ] {sin(deg(2*pi*x+(1/2)))};
  \addplot[
    only marks,
    mark options={blue!50,scale=0.75},
  ] table[x=time, y=signal] {data/spectral-leakage-ex2-seq.dat};
\end{axis}
\end{tikzpicture}

#+header: :file data/spectral-leakage-ex2-fft.dat
#+header: :session spectral-leakage2
#+begin_src python :results output silent file :hidden
fft = np.absolute(np.fft.rfft(s))
fft /= np.sum(fft)
bins = np.fft.rfftfreq(len(t))
print("bin fft")
for x, y in zip(bins, fft):
    print("{:.5f} {:.5f}".format(x * fs, y))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$f$},
  set layers=axis on top,
  xtick=data,
  xticklabel style={
    font=\footnotesize,
    fill=bg
  },
  ybar,
  legend entries={original, phase-shifted},
  legend pos=north west,
  legend style={
    fill=bg,
    draw=fgcolor
  },
]
  \addplot[fill=fgcolor] table[x=bin, y=fft] {data/spectral-leakage-ex1-fft.dat};
  \addplot[blue!75,fill=blue!75] table[x=bin, y=fft] {data/spectral-leakage-ex2-fft.dat};
\end{axis}
\end{tikzpicture}

The plot below shows the effect of using a larger FFT on the spectral
leakage. Namely, the leakage still exists, but is less
pronounced. This is expected since in the limit that the FFT length
approaches infinity, the spectral leakage should disappear.

#+header: :file data/windowing-purpose.dat
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
ts = f / 3
fs = 1 / ts

x = [np.arange(i, step=ts) for i in (5.1, 1e3 + 0.1)]
y = [np.sin(2 * np.pi * f * i) for i in x]
fft = [np.absolute(np.fft.rfft(i)) for i in y]
sample_bins = [np.fft.rfftfreq(len(i)) for i in x]
# rebin all ffts to first fft bins so they can be compared
fft_rebin = [np.zeros(len(sample_bins[0])) for i in range(len(x))]
for i, bin_cmp in enumerate(sample_bins[0]):
    if i < len(sample_bins[0]) - 1:
        next_bin = sample_bins[0][i + 1]
    else:
        # choice of 1 is arbitrary, just needs to be at least an
        # additional interval
        next_bin = bin_cmp + 1
    for bin_idx in range(1, len(x)):
        bins = sample_bins[bin_idx]
        for j, bin_other in enumerate(bins):
            if bin_other >= bin_cmp and bin_other < next_bin:
                fft_rebin[bin_idx][i] += fft[bin_idx][j]

fft_rebin[0] = fft[0]
# normalize fft
fft_norm = [i / np.sum(i) for i in fft_rebin]
print("{:5}  {:10}  {:10}".format("bin", "fft0", "fft1"))
for i, bin_val in enumerate(sample_bins[0]):
    print(
        "{:.3f}  {:.8f}  {:.8f}".format(
            bin_val * fs, fft_norm[0][i], fft_norm[1][i]
        )
    )
#+end_src

\begin{tikzpicture}
\begin{axis}[
  title=Spectral Leakage (FFT Length Effect),
  xlabel={$f$},
  ylabel={FFT Amplitude},
  ybar,
  legend entries={$N=16$, $N=3001$},
  legend pos=north west,
  legend style={
    fill=bg,
    draw=fgcolor
  },
  set layers=axis on top,
  xticklabel style={
    fill=bg
  }
]
  \addplot[fill=fgcolor] table[x=bin, y=fft0] {data/windowing-purpose.dat};
  \addplot[blue!75, fill=blue!75] table[x=bin, y=fft1] {data/windowing-purpose.dat};
\end{axis}
\end{tikzpicture}

*** Effect of Windowing on Spectral Leakage
:PROPERTIES:
:ID:       f4a4c107-8006-4ed5-ab5c-5ecfedc450e1
:END:
Certain window functions are effective at reducing spectral
leakage. For example,

#+header: :file data/window-spectral-leakage.dat
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
fs = 3 * f
ts = 1 / fs

t = np.arange(15.1, step=ts)
kaiser = np.kaiser(len(t), 6)
s = np.sin(2*np.pi*f*t)
s_kaiser = np.multiply(s, kaiser)
bins = np.fft.rfftfreq(len(s))
fft = np.absolute(np.fft.rfft(s))
fft /= np.sum(fft)
fft_kaiser = np.absolute(np.fft.rfft(s_kaiser))
fft_kaiser /= np.sum(fft_kaiser)

print("bin unwindowed windowed")
for bin_val, fft_val, fft_kaiser_val in zip(bins, fft, fft_kaiser):
    print("{:.5f} {:.5f} {:.5f}".format(bin_val * fs, fft_val, fft_kaiser_val))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  title=Effect of Windowing on Spectral Leakage,
  xlabel={$f$},
  ylabel={FFT Amplitude},
  legend entries={no window, window},
  legend style={
    fill=bg,
    draw=fgcolor
  },
  legend pos=north west,
  set layers=axis on top,
  xticklabel style={
    fill=bg
  },
  ybar,
  bar width=3pt,
]
  \addplot[fill=fgcolor] table[x=bin, y=unwindowed] {data/window-spectral-leakage.dat};
  \addplot[
    blue!50,
    fill=blue!50,
  ] table[x=bin, y=windowed] {data/window-spectral-leakage.dat};
\end{axis}
\end{tikzpicture}

We see that for the windowed function, the spectral content outside
the immediate vicinity of the signal frequency is almost zero. To
understand how the window works, it is informative to compare the
original time-domain signal with the time-domain signal after
windowing.

#+header: :file data/window-spectral-leakage-time-domain.dat
#+header: :session window-spectral-leakage
#+begin_src python :results output silent file :hidden
import numpy as np

f = 1
fs = 3 * f
ts = 1 / fs

t = np.arange(5.1, step=ts)
kaiser = np.kaiser(len(t), 6)
s = np.sin(2*np.pi*f*t)
s_kaiser = np.multiply(s, kaiser)
print("time orig windowed")
for time, s_orig, s_kais in zip(t, s, s_kaiser):
        print("{:.5f} {:.5f} {:.5f}".format(time, s_orig, s_kais))
#+end_src

#+header: :file data/window-spectral-leakage-time-domain-full-sine.dat
#+header: :session window-spectral-leakage
#+begin_src python :results output silent file :hidden
tfine = np.linspace(0, 5, num=1000)
kaiser_fine = np.kaiser(len(tfine), 6)
sfine = np.sin(2*np.pi*f*tfine)
sfine_kaiser = np.multiply(sfine, kaiser_fine)
print("time s")
for time, s in zip(tfine, sfine_kaiser):
        print("{:.5f} {:.5f}".format(time, s))
#+end_src

\begin{tikzpicture}
\begin{axis}[
  xlabel={$t$},
  axis x line=middle,
  axis y line=middle,
  set layers=axis on top,
  xticklabel style={
    fill=bg
  }
]
  \addplot[
    domain=0:5,
    samples=500,
  ] {sin(deg(2*pi*x))};
  \addplot[
    only marks,
    mark options={scale=0.75},
  ] table[x=time, y=orig] {data/window-spectral-leakage-time-domain.dat};
  \addplot[
    blue!50,
  ] table[x=time, y=s] {data/window-spectral-leakage-time-domain-full-sine.dat};
  \addplot[
    only marks,
    mark options={blue!50,scale=0.75},
  ] table[x=time, y=windowed] {data/window-spectral-leakage-time-domain.dat};
\end{axis}
\end{tikzpicture}

We see that the kaiser window works by reducing the strength of the
signal at the beginning and end of the sequence. This makes sense,
since it is these parts of the sample that create the discontinuities
and generate frequencies not present in the original signal.

*** TODO Choosing a Window Function
Check [[https://www.electronicdesign.com/technologies/analog/article/21798689/choose-the-right-fft-window-function-when-evaluating-precision-adcs][this link]].

*** Implementation
:PROPERTIES:
:ID:       b3437309-97a4-47fc-b51f-9ac373300bf8
:END:
A window function works by simply multiplying the input signal by the
window coefficients. Therefore, implementing one on an FPGA is very
easy. We can use numpy to generate the coefficients for us, write
these values in hexadecimal format to a file and load them into an
FPGA ROM with ~readmemh~. See the ~window~ module for details. The
only possibly difficult part is [[id:b7eba33e-b557-4af0-80cb-5e0fa982b567][convergent rounding]].

** FFT
:PROPERTIES:
:ID:       5535c7fa-c614-4b3e-ac41-efa5581223b6
:END:
An FFT is a computationally-efficient implementation of a DFT, which
decomposes a discretized, time-domain signal into its frequency
spectrum. The frequency is [[id:285aab15-835c-464a-9a66-043078cfda28][related to the remote object distance]], so
it's a short step from the frequency data to the final, processed
distance data.

*** Implementation
Next high level section: [[id:a0e92e3e-3444-4956-8c07-b4d14d1f2489][ADF4158 Frequency Synthesizer]]

There are several important considerations when implementing an FFT in
hardware. First, it should be pipelined in a way that allows a high
clock rate and bandwidth. Additionally, it should use as few physical
resources as possible, which for an FFT means number of multipliers,
adders and memory size. I spent some time looking through relevant
research papers to find a resource-efficient algorithm that would fit
on a low-cost FPGA. I decided on the
\(\text{R2\textsuperscript{2}SDF}\) algorithm[fn:1], which requires
that \(N\) be a power of 4 and uses \(\log_4{\left(N\right)}-1\)
complex multipliers, \(4\log_4{\left(N\right)}\) adders and \(N-1\)
memory elements.

Here's a block diagram of the hardware implementation, adapted from
the original paper.

\begin{circuitikz}[color=fgcolor]
\ctikzset{blocks/scale=0.3}
\ctikzset{multipoles/dipchip/width=0.5}
\def\butterfly{node[dipchip, num pins=4, hide numbers, no topmark, external
  pins width=0,anchor=bpin 2]}
\def\sr{node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=bpin 2]}
\def\bfs#1#2#3#4{
  \draw #1 --++(0.5,0) node[inputarrow]{}
    \butterfly(bfi){\tiny BF2I};
  \draw (bfi.bpin 4) -|++(0.5,1) --++(-0.5,0)
    node[inputarrow,rotate=180]{} \sr(sri){\tiny #2};
  \draw (sri.bpin 1) --++(-0.5,0) |- (bfi.bpin 1) node[inputarrow]{};
  \draw (bfi.bpin 3) --++(1.3,0) node[inputarrow]
    \butterfly(bfii){\tiny BF2II};
  \draw (bfi.s) node[above]{\tiny s} node[inputarrow,rotate=90]{}
    --++(0,-0.5) coordinate(bfia) --++(0,-0.5);
  \draw (bfia) -| ($(bfii.s)-(0.15,0)$) node[inputarrow,rotate=90]{}
    node[above]{\tiny t};
  \draw ($(bfii.s)+(0.15,0)$) node[inputarrow,rotate=90]{}
    node[above]{\tiny s} --++(0,-1);
  \draw (bfii.bpin 4) -|++(0.5,1) --++(-0.5,0)
    node[inputarrow,rotate=180]{} \sr(srii){\tiny #3};
  \draw (srii.bpin 1) --++(-0.5,0) |- (bfii.bpin 1) node[inputarrow]{};
  \draw (bfii.bpin 3) --++(0.5,0) node[inputarrow]{} coordinate(#4);
}
\def\mix#1#2#3{
  \draw #1 node[mixer,anchor=1](mix){};
  \draw (mix.2) node[inputarrow,rotate=90]{} --++(0,-0.5)
    node[below]{\tiny #2};
  \draw (mix.3) coordinate(#3);
}
\draw (0,0) node[left]{$x(n)$} \bfs{(0,0)}{$N/2$}{$N/4$}{a}
  \mix{(a)}{$W1(n)$}{b};
\bfs{(b)}{$N/8$}{$N/16$}{c} \mix{(c)}{$W2(n)$}{d};
\draw (d) --++(0.5,0) node[inputarrow]{} coordinate(e);
\draw ($(e)+(0.5,0)$) node[]{$\ldots$};
\bfs{($(e)+(1,0)$)}{$2$}{$1$}{f};
\draw (f) node[right]{$X(k)$};
\end{circuitikz}

And here's a detailed schematic of the last 2 stages.


\begin{circuitikz}
\def\col{fgcolor}
\tikzset{
  s0bf1/.pic={
    %% shift regs
    \foreach \y/\i in {1.25/7,1.65/6,2.05/5,2.45/4,2.85/3,3.25/2,3.65/1,4.05/0} {
      \draw (-0.3125,\y) rectangle ++(1,0.4);
      \draw (0.1875,\y+0.2) node[font=\tiny] {\texttt{sr[\i]}};
      \fill[\col] (0.1875-0.05,\y) --++(0.1,0) --++(-0.05,0.1) --cycle;
    }
    \foreach \y in {1.65,2.05,2.45,2.85,3.25,3.65,4.05} {
      \draw (0.6875,\y-0.1) node[inputarrow,rotate=180,color=\col] (0.6875,\y-0.1);
      \draw (0.6875,\y-0.1) --++(0:0.5) --++(90:0.2) --++(180:0.5);
    }
    %% xfsr re
    \draw (0,0)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw (-0.3125,1.35) to[short,-,l=$\texttt{re}$] (-2,1.35) -- (-2,0.66);
    \draw (-1.75,0.66) to[short,*-,color=\col] (-1.75,-2.6)
      --++(1.30675,0) --++(0,0.25) node[inputarrow,rotate=90,color=\col];
    \draw ($(C)!0.33!(O)$) --++(180:1) ++(-0.05,0) node[inputarrow,color=\col];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33)
      to[short,-,color=\col] ++(180:1);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:2.5)--++(0,-2.125)--++(1.15,0);
    \draw ($(A)!0.5!(B)$)++(2.9,-3.775) node[below] {\texttt{-}};
    \draw ($(A)!0.5!(B)$)++(0:2.5)++(0,-2.125)
      to[short,*-,color=\col] ++(0,-1.65) --++(1.15,0);
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% xfsr im
    \draw (0,-1.25)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw (-0.3125,1.55) to[short,-] (-2.5,1.55)
      ++(1.15625,0) node[above] {\texttt{im}} ++(-1.15625,0)
      -- (-2.5,0.66-1.25);
    \draw (-2.25,0.66-1.25) to[short,*-,color=\col] (-2.25,-3.85)
      --++(1.80675,0) --++(0,0.25) node[inputarrow,rotate=90,color=\col];
    \draw ($(C)!0.33!(O)$) --++(180:1) ++(-0.05,0)
      node[inputarrow,color=\col] --++(180:1.45);
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)++(0:2)--++(0,-1.2525)--++(1.65,0);
    \draw ($(A)!0.5!(B)$)++(0:2)++(0,-1.2525)
      to[short,*-,color=\col] ++(0,-0.9) --++(1.65,0);
    %%\draw ($(A)!0.5!(B)$)++(3.1,-1.2525) node[below] {\texttt{-}};
    \draw ($(A)!0.5!(B)$)--++(0:2);
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% x re
    \draw (0,-2.5)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw ($(C)!0.33!(O)$)--++(180:1) to[short,-,color=\col] ++(180:1.5) node[left] {\texttt{x\_re(15) ... x\_re(1) x\_re(0)}};
    \draw ($(C)!0.33!(O)$) ++(180:2) to[short,*-,color=\col] ++(90:1.5)
      --++(0:1.55) --++(90:0.45) node[inputarrow,color=\col,rotate=90];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) ++(-0.2,-0.2) node[] {\texttt{-}}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:1.75) ++(0,0) node[above left] {\texttt{re}}
      ++(0,0) --++(90:7)--++(180:2.25)--++(-90:0.55) node[inputarrow,rotate=-90,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% x im
    \draw (0,-3.75)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw ($(C)!0.33!(O)$)--++(180:1) to[short,-,color=\col] ++(180:1.5) node[left] {\texttt{x\_im(15) ... x\_im(1) x\_im(0)}};
    \draw ($(C)!0.33!(O)$) ++(180:1.5) to[short,*-,color=\col] ++(90:1.5)
      --++(0:1.05) --++(90:0.45) node[inputarrow,color=\col,rotate=90];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) ++(-0.2,-0.2) node[] {\texttt{-}}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
      node[left] {\texttt{0}};
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:1) ++(0,0) node[above left] {\texttt{im}}
      ++(0,0) --++(90:8)--++(180:1)--++(-90:0.3) node[inputarrow,rotate=-90,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) --++(-90:0.25) node[below,font=\small]{$\texttt{sel0i}$};
  }
}
\tikzset{
  s0bf2/.pic={
    %% shift regs
    \foreach \y/\i in {1.25/3,1.65/2,2.05/1,2.45/0} {
      \draw (-0.3125,\y) rectangle ++(1,0.4);
      \draw (0.1875,\y+0.2) node[font=\tiny] {\texttt{sr[\i]}};
      \fill[\col] (0.1875-0.05,\y) --++(0.1,0) --++(-0.05,0.1) --cycle;
    }
    \foreach \y in {1.65,2.05,2.45} {
      \draw (0.6875,\y-0.1) node[inputarrow,rotate=180,color=\col] (0.6875,\y-0.1);
      \draw (0.6875,\y-0.1) --++(0:0.5) --++(90:0.2) --++(180:0.5);
    }
    %% xfsr re
    \draw (0,0)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw (-0.3125,1.35) to[short,-,l=$\texttt{re}$] (-2,1.35) -- (-2,0.66);
    \draw (-1.75,0.66) to[short,*-,color=\col] (-1.75,-2.6)
      --++(1.30675,0) --++(0,0.25) node[inputarrow,rotate=90,color=\col];
    \draw ($(C)!0.33!(O)$) --++(180:1) ++(-0.05,0) node[inputarrow,color=\col];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33)
      to[short,--,color=\col] ++(180:1);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:2.5)--++(0,-2.25)--++(1.37,0) node[inputarrow,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% xfsr im
    \draw (0,-1.25)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw (-0.3125,1.55) to[short,-] (-2.5,1.55)
      ++(1.15625,0) node[above] {\texttt{im}} ++(-1.15625,0)
      -- (-2.5,0.66-1.25);
    \draw (-2.25,0.66-1.25) to[short,*-,color=\col] (-2.25,-3.85)
      --++(1.80675,0) --++(0,0.25) node[inputarrow,rotate=90,color=\col];
    \draw ($(C)!0.33!(O)$) --++(180:1) ++(-0.05,0)
      node[inputarrow,color=\col] --++(180:1.45);
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:2)--++(0,-1.55)--++(1.9,0) node[inputarrow,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% x re
    \draw (0,-2.5)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw ($(C)!0.33!(O)$)--++(180:1) to[short,-,color=\col] ++(180:1.5)
      ++(-0.425,-0.5) coordinate (O1)--++(30:0.5)coordinate (A1)--++(90:0.5)coordinate (B1)--++(150:0.5)coordinate (C1)--cycle;
    \draw ($(C1)!0.33!(O1)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    \draw ($(C1)!0.66!(O1)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    \draw ($(C)!0.33!(O)$) ++(180:2) to[short,*-,color=\col] ++(90:1.5)
      --++(0:1.55) --++(90:0.45) node[inputarrow,color=\col,rotate=90];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) ++(-0.2,-0.2) node[] {\texttt{-}}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:1.75) ++(0,0) node[above left] {\texttt{re}}
      ++(0,0) --++(90:5.4)--++(180:2.25)--++(-90:0.55) node[inputarrow,rotate=-90,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% x im
    \draw (0,-3.75)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw ($(C)!0.33!(O)$)--++(180:1) to[short,-,color=\col] ++(180:1.5)
      ++(-0.425,-0.5) coordinate (O1)--++(30:0.5)coordinate (A1)--++(90:0.5)coordinate (B1)--++(150:0.5)coordinate (C1)--cycle;
    \draw ($(C1)!0.33!(O1)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    \draw ($(C1)!0.66!(O1)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    \draw ($(C)!0.33!(O)$) ++(180:1.5) to[short,*-,color=\col] ++(90:1.5)
      --++(0:1.05) --++(90:0.45) node[inputarrow,color=\col,rotate=90];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) ++(-0.2,-0.2) node[] {\texttt{-}}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
      node[left] {\texttt{0}};
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:1) ++(0,0) node[above left] {\texttt{im}}
      ++(0,0) --++(90:6.4)--++(180:1)--++(-90:0.3) node[inputarrow,rotate=-90,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) --++(-90:1) node[right,font=\small]{$\texttt{sel0ii}$};

    %% sel and tsel
    \draw ($(O)!0.5!(A)$)++(-1.5,-0.75) node[and port,rotate=180,color=\col,scale=0.5] (myand) {};
    \node at (myand.bin 1) [ocirc,right,color=\col]{};
    \draw (myand.in 1) --++(0.5,0) --++(0,-0.36) node[below,font=\small] {$\texttt{sel0i}$};
    \draw (myand.in 2) to[short,-*,color=\col] ++(1.3,0);
    \draw (myand.out) --++(-1.35,0) to[short,*-,color=\col] ++(0,0) --++(0,0.92);
    \draw (myand.out) ++(-1.35,0) --++(-0.5,0)--++(0,1.9)--++(0.5,0)--++(0,0.25);
  }
}
\tikzset{
  s1bf1/.pic={
    %% shift regs
    \foreach \y/\i in {1.25/1,1.65/0} {
      \draw (-0.3125,\y) rectangle ++(1,0.4);
      \draw (0.1875,\y+0.2) node[font=\tiny] {\texttt{sr[\i]}};
      \fill[\col] (0.1875-0.05,\y) --++(0.1,0) --++(-0.05,0.1) --cycle;
    }
    \foreach \y in {1.65} {
      \draw (0.6875,\y-0.1) node[inputarrow,rotate=180,color=\col] (0.6875,\y-0.1);
      \draw (0.6875,\y-0.1) --++(0:0.5) --++(90:0.2) --++(180:0.5);
    }
    %% xfsr re
    \draw (0,0)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw (-0.3125,1.35) to[short,-,l=$\texttt{re}$] (-2,1.35) -- (-2,0.66);
    \draw (-1.75,0.66) to[short,*-,color=\col] (-1.75,-2.6)
      --++(1.30675,0) --++(0,0.25) node[inputarrow,rotate=90,color=\col];
    \draw ($(C)!0.33!(O)$) --++(180:1) ++(-0.05,0) node[inputarrow,color=\col];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33)
      to[short,-,color=\col] ++(180:1);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:2.5)--++(0,-2.125)--++(1.15,0);
    \draw ($(A)!0.5!(B)$)++(2.9,-3.775) node[below] {\texttt{-}};
    \draw ($(A)!0.5!(B)$)++(0:2.5)++(0,-2.125)
      to[short,*-,color=\col] ++(0,-1.65) --++(1.15,0);
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% xfsr im
    \draw (0,-1.25)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw (-0.3125,1.55) to[short,-] (-2.5,1.55)
      ++(1.15625,0) node[above] {\texttt{im}} ++(-1.15625,0)
      -- (-2.5,0.66-1.25);
    \draw (-2.25,0.66-1.25) to[short,*-,color=\col] (-2.25,-3.85)
      --++(1.80675,0) --++(0,0.25) node[inputarrow,rotate=90,color=\col];
    \draw ($(C)!0.33!(O)$) --++(180:1) ++(-0.05,0)
      node[inputarrow,color=\col] --++(180:1.45);
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)++(0:2)--++(0,-1.2525)--++(1.65,0);
    \draw ($(A)!0.5!(B)$)++(0:2)++(0,-1.2525)
      to[short,*-,color=\col] ++(0,-0.9) --++(1.65,0);
    %%\draw ($(A)!0.5!(B)$)++(3.1,-1.2525) node[below] {\texttt{-}};
    \draw ($(A)!0.5!(B)$)--++(0:2);
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% x re
    \draw (0,-2.5)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw ($(C)!0.33!(O)$)--++(180:1) to[short,-,color=\col] ++(180:2.5);
    \draw ($(C)!0.33!(O)$) ++(180:2) to[short,*-,color=\col] ++(90:1.5)
      --++(0:1.55) --++(90:0.45) node[inputarrow,color=\col,rotate=90];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) ++(-0.2,-0.2) node[] {\texttt{-}}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:1.75) ++(0,0) node[above left] {\texttt{re}}
      ++(0,0) --++(90:4.6)--++(180:2.25)--++(-90:0.55) node[inputarrow,rotate=-90,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% x im
    \draw (0,-3.75)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw ($(C)!0.33!(O)$)--++(180:1)
      to[short,-,color=\col] ++(180:1.5) --++(90:0.85) --++(180:1);
    \draw ($(C)!0.33!(O)$) ++(180:1.5) to[short,*-,color=\col] ++(90:1.5)
      --++(0:1.05) --++(90:0.45) node[inputarrow,color=\col,rotate=90];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) ++(-0.2,-0.2) node[] {\texttt{-}}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
      node[left] {\texttt{0}};
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:1) ++(0,0) node[above left] {\texttt{im}}
      ++(0,0) --++(90:5.6)--++(180:1)--++(-90:0.3) node[inputarrow,rotate=-90,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) --++(-90:0.25) node[below,font=\small]{$\texttt{sel1i}$};
  }
}
\tikzset{
  s1bf2/.pic={
    %% shift regs
    \foreach \y/\i in {1.25/0} {
      \draw (-0.3125,\y) rectangle ++(1,0.4);
      \draw (0.1875,\y+0.2) node[font=\tiny] {\texttt{sr[\i]}};
      \fill[\col] (0.1875-0.05,\y) --++(0.1,0) --++(-0.05,0.1) --cycle;
    }
    %% xfsr re
    \draw (0,0)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw (-0.3125,1.35) to[short,-,l=$\texttt{re}$] (-2,1.35) -- (-2,0.66);
    \draw (-1.75,0.66) to[short,*-,color=\col] (-1.75,-2.6)
      --++(1.30675,0) --++(0,0.25) node[inputarrow,rotate=90,color=\col];
    \draw ($(C)!0.33!(O)$) --++(180:1) ++(-0.05,0) node[inputarrow,color=\col];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33)
      to[short,--,color=\col] ++(180:1);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:2.5)--++(0,-2.25)--++(1.37,0) node[inputarrow,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% xfsr im
    \draw (0,-1.25)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw (-0.3125,1.55) to[short,-] (-2.5,1.55)
      ++(1.15625,0) node[above] {\texttt{im}} ++(-1.15625,0)
      -- (-2.5,0.66-1.25);
    \draw (-2.25,0.66-1.25) to[short,*-,color=\col] (-2.25,-3.85)
      --++(1.80675,0) --++(0,0.25) node[inputarrow,rotate=90,color=\col];
    \draw ($(C)!0.33!(O)$) --++(180:1) ++(-0.05,0)
      node[inputarrow,color=\col] --++(180:1.45);
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:2)--++(0,-1.55)--++(1.9,0) node[inputarrow,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% x re
    \draw (0,-2.5)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw ($(C)!0.33!(O)$)--++(180:1) to[short,-,color=\col] ++(180:1.5)
      ++(-0.425,-0.5) coordinate (O1)--++(30:0.5)coordinate (A1)--++(90:0.5)coordinate (B1)--++(150:0.5)coordinate (C1)--cycle;
    \draw ($(C1)!0.33!(O1)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    \draw ($(C1)!0.66!(O1)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    \draw ($(C)!0.33!(O)$) ++(180:2) to[short,*-,color=\col] ++(90:1.5)
      --++(0:1.55) --++(90:0.45) node[inputarrow,color=\col,rotate=90];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) ++(-0.2,-0.2) node[] {\texttt{-}}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:1.75) ++(0,0) node[above left] {\texttt{re}}
      ++(0,0) --++(90:4.2)--++(180:2.25)--++(-90:0.55) node[inputarrow,rotate=-90,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) to[short,-*,color=\col] ++(-90:1.25);

    %% x im
    \draw (0,-3.75)coordinate (O)--++(30:0.5)coordinate (A)--++(90:0.5)coordinate (B)--++(150:0.5)coordinate (C)--cycle;
    % 0 input
    \draw ($(C)!0.33!(O)$)--++(180:1) to[short,-,color=\col] ++(180:1.5)
      ++(-0.425,-0.5) coordinate (O1)--++(30:0.5)coordinate (A1)--++(90:0.5)coordinate (B1)--++(150:0.5)coordinate (C1)--cycle;
    \draw ($(C1)!0.33!(O1)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    \draw ($(C1)!0.66!(O1)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    \draw ($(C)!0.33!(O)$) ++(180:1.5) to[short,*-,color=\col] ++(90:1.5)
      --++(0:1.05) --++(90:0.45) node[inputarrow,color=\col,rotate=90];
    \draw ($(C)!0.33!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{0}$};
    % 1 input
    \draw ($(C)!0.66!(O)$)--++(180:0.25) ++(180:0.2)
      node[adder,color=\col,scale=0.4,name=A1BF1] {}
      (A1BF1.west) ++(-0.2,-0.2) node[] {\texttt{-}}
      (A1BF1.west) node[inputarrow,color=\col] --++(180:0.35)
      to[short,-*,color=\col] ++(90:0.33);
      node[left] {\texttt{0}};
    \draw ($(C)!0.66!(O)$)++(180:0.0625) node[right,font=\small] {$\texttt{1}$};
    % output
    \draw ($(A)!0.5!(B)$)--++(0:1) ++(0,0) node[above left] {\texttt{im}}
      ++(0,0) --++(90:5.2)--++(180:1)--++(-90:0.3) node[inputarrow,rotate=-90,color=\col];
    % sel
    \draw ($(O)!0.5!(A)$)--++(-90:0.25) --++(0:0.5) --++(-90:1) node[right,font=\small]{$\texttt{sel1ii}$};

    %% sel and tsel
    \draw ($(O)!0.5!(A)$)++(-1.5,-0.75) node[and port,rotate=180,color=\col,scale=0.5] (myand) {};
    \node at (myand.bin 1) [ocirc,right,color=\col]{};
    \draw (myand.in 1) --++(0.5,0) --++(0,-0.36) node[below,font=\small] {$\texttt{sel1i}$};
    \draw (myand.in 2) to[short,-*,color=\col] ++(1.3,0);
    \draw (myand.out) --++(-1.35,0) to[short,*-,color=\col] ++(0,0) --++(0,0.92);
    \draw (myand.out) ++(-1.35,0) --++(-0.5,0)--++(0,1.9)--++(0.5,0)--++(0,0.25);
  }
}
  %%% stage 0 BF1
  \path(0,0) pic{s0bf1};
  %%% stage 0 BF2
  \path(7,0) pic{s0bf2};
  %%% mixer
  \draw (12,-2) node[mixer,color=\col,scale=1.5] (mix0) {};
  \draw (mix0.south) node[inputarrow,rotate=90,color=\col] --++(0,-1)
    node[below] {\texttt{W1(n)}};
  \draw (mix0.east)++(-0.08,0.25) to[short,-,l=$\texttt{re}$] ++(0.85,0) node[inputarrow,color=\col];
  \draw (mix0.east)++(-0.08,-0.25) to[short,-,l=$\texttt{im}$] ++(0.85,0) node[inputarrow,color=\col];
  %%% register
  \draw (13.5,-2) to[twoport,t=\texttt{REG},color=\col] (14.5,-2);
  \fill[\col] (14-0.1,-2.5) --++(0.2,0) --++(-0.1,0.2) --cycle;
  \draw(15,-1.8) node[above] {\texttt{re}};
  \draw(15,-2.2) node[below] {\texttt{im}};
  %%% stage 1 BF1
  \path(18,0) pic{s1bf1};
  %%% stage 1 BF2
  \path(25,0) pic{s1bf2};
\end{circuitikz}

There are a few things to notice here. Each shift register only
requires 1 read and 1 write port and therefore can be implemented
using dual-port block RAM. I've only done this for the sufficiently
large shift registers where it's worth it (see the Verilog file for
details). I've also added a register after the complex multiplier to
show how this can be pipelined. I use more pipeline stages in the
actual implementation. Lastly, the multiplier in the diagram is a
complex multiplier meaning it requires 4 real multipliers. However,
it's possible to use a single DSP slice for this. The first step in
achieving this involves using 3 multiplies instead of 4. The general
form for a complex multiplication is

\(\begin{aligned}
R+iI &= (a+ib) \times (c+id).\\
\end{aligned}\)

However, if we precompute the following values

\(\begin{aligned}
e&=a-b\\
f&=c\times e\\
\end{aligned}\)

then, the result can be achieved with

\(\begin{aligned}
R &= b(c-d) + f\\
I &= a(c+d) - f\\
\end{aligned}\)

The second step is to realize that, like with the [[id:491617b7-7ba2-4a76-9a68-89ff7f8608b9][FIR filter]], we can
run our DSP slice much faster than the general FFT clock rate of
\(\SI{40}{MHz}\). By time multiplexing the DSP slice and using the
fact that DSP slices are good at multiply-accumulate operations and
not just multiply operations, we can run the DSP slice at
\(\SI{120}{MHz}\). In the first clock period we compute \(f\) above,
and then use that value in the next 2 clock periods to compute \(R\)
and \(I\).

**** TODO potential alternative
\begin{circuitikz}[color=fgcolor]
\ctikzset{multipoles/dipchip/pin spacing=0.3}
\ctikzset{multipoles/dipchip/width=0.75}
\ctikzset{multipoles/thickness=1}
\def\inteval#1{%
  \pgfmathparse{int(#1)}\pgfmathresult
}
\def\srblock{%
  node[dipchip, num pins=2, hide numbers, no topmark, external
  pins width=0,anchor=s]
}
\def\sr#1#2{%
  \path #1 coordinate(_a);
  \foreach \reg in {1,...,#2} {
    \draw (_a) \srblock(blk){\footnotesize \inteval{#2+1-\reg}};
    \path (blk.n) coordinate(_a);
  }
}
%\def\butterfly#1{
%}
\sr{(0,0)}{7}
\end{circuitikz}

** TODO ADF4158 Frequency Synthesizer
:PROPERTIES:
:ID:       a0e92e3e-3444-4956-8c07-b4d14d1f2489
:END:
Is this section necessary?

** TODO FT245
** Additional Considerations
*** Formal Verification and Testing
A number of Verilog modules use [[https://symbiyosys.readthedocs.io/en/latest/quickstart.html][Symbiyosys]] for formal
verification. None of the modules are thoroughly verified; instead
I've used it primarily as an additional form of testing. See the code
for details (the asynchronous FIFO module is a good example).

I've used [[https://cocotb.readthedocs.io/en/latest/introduction.html][Cocotb]] for creating and running automated test
benches. Again, see code for details.

*** TODO Convergent Rounding
:PROPERTIES:
:ID:       b7eba33e-b557-4af0-80cb-5e0fa982b567
:END:
* PC Software
:PROPERTIES:
:ID:       a434cb1f-9f49-407b-aa58-2d561982d98d
:END:
Although most of the data processing is performed on the FPGA, the
host PC software still has several non-trivial tasks. Most
importantly, it has to perform some form of error detection so that
bytes lost during transmission do not lead to erroneous data in the
final output. Additionally, I've setup the software to be able to
request any intermediate form of data on the FPGA (see the [[id:6d0ccb21-c85b-417a-961e-5bbfb78717d9][FPGA
section]] for how this is implemented on the FPGA side), and can perform
all the processing steps the FPGA can perform. This means that we can
share data processing steps arbitrarily between hardware and
software. For instance, we could request that filtering be performed
on the FPGA and windowing and the FFT be performed in software. In
that case, the final output plot should be identical (albeit updated
more slowly) to what we would get if everything had been performed on
the FPGA. This makes the hardware much easier to debug since we can
directly compare the hardware result to the software result.

Finally, I've multithreaded the program so that reading data from the
radar, processing and plotting the data, and getting user input are
all separate threads. This is shown in the block diagram below.

\begin{circuitikz}[color=fgcolor]
\ctikzset{multipoles/dipchip/width=1.25}
\ctikzset{multipoles/dipchip/pin spacing=0.25}
\def\block#1{%
  node[dipchip, num pins=10, hide numbers, no topmark, external pins
  width=0, anchor=#1]
}
\def\circleBuf#1#2#3{%
  \def\largeRad{1}
  \def\smallRad{0.8}
  \def\angleUnit{20}
  \draw #1 circle[radius=\largeRad]{};
  \draw #1 circle[radius=\smallRad]{};
  \foreach \ang in {0,\angleUnit,...,360}{
    \draw ($#1+(\ang:\smallRad)$) -- ($#1+(\ang:\largeRad)$);
  }
  \path ($#1+(225:\largeRad)$) coordinate(#2);
  \path ($#1+(315:\largeRad)$) coordinate(#3);
  \draw #1 node[align=center]{\footnotesize shared\\\footnotesize buffer};
}
\draw (0,0) node[left=2pt]{\footnotesize radar}
  node[ocirc,fill=bgcolor,anchor=0]{} --++(1,0) node[inputarrow]{}
  \block{bpin 3}(producer){};
\draw (producer.center) node[align=center]{\footnotesize
  producer\\\footnotesize thread};
\circleBuf{($(producer.n)+(2,2)$)}{a}{b}
\draw[->] (producer.n) -- (a);
\draw($(producer.n)+(4,0)$) \block{n}(consumer){};
\draw (consumer.center) node[align=center]{\footnotesize
  consumer\\\footnotesize thread};
\draw[->] (b) -- (consumer.n);
\draw (consumer.bpin 8) --++(1,0) node[inputarrow]{}
  node[cylinder,shape aspect=0.5,draw,anchor=west](pipe){\footnotesize
  pipe};
\draw ($(pipe.east)-(0.11,0)$) --++(1,0) node[inputarrow]{} \block{bpin
  3}(plot){};
\draw (plot.center) node[align=center]{\footnotesize plot};
\draw ($(producer.s)+(2,-1)$) \block{n}(monitor){};
\draw (monitor.center) node[align=center]{\footnotesize
  monitor\\\footnotesize thread};
\gettikzxy{(monitor.center)}{\monx}{\mony}
\draw (0,\mony) node[left=2pt]{\footnotesize user input}
  node[ocirc,fill=bgcolor,anchor=0]{} -- (monitor.bpin 3)
  node[inputarrow]{};
\draw[dashed] ($(pipe.north)+(0,4)$) node[below left]{C} node[below
  right]{Python} -- (pipe.north);
\draw[dashed] (pipe.south) -- ($(pipe.south)-(0,4)$);
\end{circuitikz}

This means that reading data from the radar does not block processing
and plotting it and vice versa (at least until the internal buffer
fills up). Additionally, since user input gets its own thread, the
program responds immediately to user input. Currently, this isn't
very useful because the only possible user input after the program
starts is to terminate the program. However, this will be useful when
I extend the software the be able to change the data requested and
plotted output while running.

* RF Simulations
** Microstrip
:PROPERTIES:
:ID:       f361bbcc-7225-453e-a107-3f4793e4dd4a
:END:
*** via fence
*** SMT ground cutout
** Wilkinson power divider
** Attenuator
** SMA connector
** Couplers
*** 3dB
*** 5dB
*** 6dB
** Antennas
*** Horn
*** Patch Array
* Spice Simulations
* OLD
** block diagram
** physics
This FMCW radar can compute the 2-dimensional position to remote
objects. It does this by computing the range and angle. Unlike some
other radars, this radar does not measure doppler shift and as a
result does not directly measure the speed of remote objects. However,
the speed can be computed by taking the change in position over time.

*** range
The distance computation is performed by measuring the time between
when a signal is transmitted and when it is received after having
bounced off a remote object. Using the relationship between the speed
of light and time of travel, we can back out the distance to a remote
target.

\(\displaystyle
d = \frac{ct_d}{2}
\)

In order to measure the round-trip travel time, we transmit a
sinusoidal signal that ramps in frequency at a predetermined rate
between predetermined start and stop frequencies. The frequency-time
graph of the transmitted and received signals is shown below.

#+caption: FMCW frequency ramp.
[[./data/fmcw-principle.png]]

Since we know the ramp rate and duration of one ramp, we can replace
our dependence on round-trip time with a dependence on frequency
difference between our transmitted and received signals.

\(\displaystyle
d = \frac{ct_{\text{ramp}} \Delta f}{2f_{\text{ramp}}}
\)

Take the equation for a transmitted signal as

\(\begin{aligned}
  s_{\text{t}}(t) &= T \sin\left(\omega_{\text{t}}(t) t\right)  && \text{$T$ is the transmitted
                                                                   signal's amplitude.} \\
                  &= T \sin\left(2 \pi f(t) t\right) \\
                  &= T \sin\left(2 \pi t \left( f_0 + t \frac{f_{\text{ramp}}}{t_{\text{ramp}}}
                    \right) \right)
\end{aligned}\)

The corresponding received signal is (ignoring the doppler shift which
is insignificant at the speeds we care about)

\(\begin{aligned}
  s_{\text{r}}(t) &= R \sin\left(\omega_{\text{r}}(t) t\right) \\
                  &= R \sin\left(\omega_{\text{t}}(t-t_d) t\right) \\
                  &= R \sin\left(2 \pi f(t-t_d) t\right) \\
                  &= R \sin\left(2 \pi t \left( f_0 + (t-t_d) \frac{f_{\text{ramp}}}{t_{\text{ramp}}}
                    \right) \right)
\end{aligned}\)

Mixing the transmitted and received signals gives

\(\begin{aligned}
  m &= TR \sin\left(2 \pi t \left( f_0 + t \frac{f_{\text{ramp}}}{t_{\text{ramp}}}
                    \right) \right)
      \sin\left(2 \pi t \left( f_0 + (t-t_d) \frac{f_{\text{ramp}}}{t_{\text{ramp}}}
      \right) \right) \\
  \sin\theta\sin\phi &= \frac{1}{2} \left[\cos(\theta-\phi) -
                       \cos(\theta+\phi)\right] \\
  &\approx \frac{1}{2}\cos(\theta-\phi) && \texttt{$\cos(\theta+\phi)$ is too high to
    detect} \\
  m &\approx \frac{1}{2}TR\cos(2\pi\Delta f t)
\end{aligned}\)

We can compute the fourier transform of the mixer output to get the
frequency and then plug that into the range equation above to get the
distance to the target. The amplitude of the mixer output is related
to strength of the signal.

*** angle
The angle to the target is computed by beamforming
(i.e. phase-shifting one channel and summing both channels). See
hforsten's blog post for a description of this.

**** WRONG
To compute the angle to our target we can find the difference in
distance computed by each channel. Naively, we could try to do this by
using the same method as for the range calculation (i.e. compute the
difference in the difference frequencies). However, the difference
between the frequencies picked up by each receiver channel would be
too small to detect. To see this, solve the distance equation above
using a max distance difference of $\lambda/2$ (the distance between the
receiver antennas). Using a center frequency of 5.6GHz and a ramp
bandwidth of 600MHz, we get a maximum difference frequency of
200Hz. When we compute the [[id:9a522962-63bc-4569-b042-3b691549b8a6][fourier transform]], the frequency bins will
be spaced at 600kHz, which is way too crude to detect a 200Hz
difference frequency.

Instead, we can use the phase difference between the signals

** modules
*** fpga
At startup, configure the ADF4158. Then, perform 8 consecutive signal
ramps where each ramp delay is 2us and each duration is 0.512ms
(0.512ms to pick up all 1024 desired samples, plus a delay at the
beginning to avoid picking up any signals from the previous ramp,
corresponding to the max distance of 250m). The first ramp is for
antennas 1 and 2. The second is for antennas 3 and 4. The third and
fourth are for antennas 5 and 6, and 7 and 8, respectively. The fifth
ramp is for antennas 1 and 2 again. And so on until 8 ramps have
completed. The FIR polyphase decomposition filter is performed in
realtime during sampling. Additionally, since each antenna is recorded
twice and averaged, we store 4x 1024, 16-bit samples (i.e. 65kb
total).

**** state machine

\begin{latex}
\usetikzlibrary{positioning}
\usetikzlibrary{automata}
\begin{tikzpicture}[shorten >=1pt, auto]
  \node[state,initial] (adfconfig) {$\texttt{ADF config}$ \nodepart{lower} adf4158.enable=1};
  \node[state, node distance=4] (fir) [right=of adfconfig] {$\texttt{FIR}$};
  \node[state] (fifo) [right=of fir] {$\texttt{FIFO}$};
  \node[state] (fft) [right=of fifo] {$\texttt{FFT}$};
  \node[state] (ft245) [right=of fft] {$\texttt{FT245}$};

  \path[->] (adfconfig) edge node {adf\_config\_done} (fir);
\end{tikzpicture}
\end{latex}

*** frequency synthesizer
Each frequency step is 300kHz and lasts $0.5\si{\mu s}$. There are 1028 steps.

*** USB interface
A FT2232H chip is used to pass data between the host PC and FPGA. It
is used in 245 synchronous FIFO mode, which allows USB 2.0 high-speed
transfer rates (480Mb/s).

**** write transaction
A write transaction transmits data from the FPGA to the host PC.

***** timing details
The FPGA sends the FT2232H chip data for transmission using the 8-bit
ADBUS channel. The FT2232H registers this data and sends it over the
DM and DP USB data lines to the PC. FT2232H signals that it can
receive new data for transmission by driving the TXE# line low. When
the TXE# line is low, the FPGA can signal data for transmission by
driving the WR# line low and making the data available on the ADBUS
channel.

#+caption: FT2232H write transaction timing diagram. The setup time
#+caption: for WR# and ADBUS0 is between 1/2 and 1 clock period.

\begin{tikztimingtable}[%
  timing/dslope=0.1,
  timing/.style={x=5ex,y=2ex},
  x=5ex,
  timing/rowdist=3ex,
  timing/name/.style={font=\sffamily\scriptsize}
]
\busref{CLKOUT (60MHz)} & 25{c} \\
\busref{TXE\#}          & 3h 20l 2h \\
\busref{WR\#}           & 5h 18l 2h \\
\busref{ADBUS[7:0]}     & 5x 3d{0} 2d{1} 2d{2} 2d{3} 2d{4} 2d{5} 2d{6} 2d{7} 3x \\
\extracode
  \begin{pgfonlayer}{background}
    \begin{scope}[thick]
      \vertlines[blue]{3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5}
    \end{scope}
  \end{pgfonlayer}
\end{tikztimingtable}

**** read transaction
A read transaction sends data from the host PC to the FPGA.
*** receiver
*** digitization
The ADC reads both analog input channels simultaneously and
multiplexes the digital output on its 12-bit digital output
channel. Channel A data is output roughly in line with the clock at
high voltage and channel B is output roughly in line with the clock at
low voltage.

*** signal processing
The FPGA receives a 12-bit sample from each channel every 25ns (40MHz)
over a sweep duration of 1ms. Following the 1ms sweep, no data is
received for 2ms after which the process repeats.

**** big picture
There are 8 antennas multiplexed over 2 receiver channels. Data is
sampled at 40MHz with a twos complement precision of 12 bits. The data
is filtered in real time by a polyphase decomposition FIR filter that
removes signals over 1MHz (transition band from 0.95-1MHz). The
polyphase filter downsamples to 2MHz. The reason for filtering >1MHz
and downsampling to 2MHz is that once we downsample, our new sampling
frequency will be 2MHz and so we won't be able to detect any
frequencies above 1MHz. In fact, I believe any frequencies >1MHz will
show up (incorrectly) as frequencies below 1MHz (this is aliasing). We
want 1024 samples per channel (for the FFT) which, at 2MHz, means a
sweep duration of just over 0.5ms (set with the ADF4158
registers). There should then be a short delay of about 2us so that we
don't sample a signal transmitted in a previous sweep. We sample every
antenna twice and average over both sample sets, leaving 8 sequences
of 1024 12-bit data points stored in block ram. We then perform an FFT
on each of these 8 sequences. Then we perform an FFT across the angle
dimension.

**** filters
***** FIR
Use a polyphase decimation filter as described in Discrete-Time Signal
Processing page 182.

\begin{latex}
  \def\dff(#1){
  }
  \begin{circuitikz}
    \node at (0,-2) [twoport,draw,t=$\texttt{M}$] {};
  \end{circuitikz}
\end{latex}

***** kaiser window
After the FIR filter, a kaiser window is applied to the sample. This
also occurs in real-time on the sample and involves a simple pointwise
multiplication of each kaiser window coefficient by each sample.

**** downsampling
In order to make our data easier to process, we decimate it down to
2MHz. This leaves us with 2000 samples per channel per 3ms.

***** TODO correspondence b/e new frequency and max distance

**** fft
:PROPERTIES:
:ID:       9a522962-63bc-4569-b042-3b691549b8a6
:END:
After downsampling we perform a real FFT. By pipelining, we can
perform this in real-time as the signal is sampled. See the ZipCPU
tutorial on how to do this.

***** broad strokes
We sample each receiver channel at a frequency of 2MHz over 1ms. This
corresponds to 2000 samples per channel per sweep. We then take the
FFT of each channel, which yields 2000 frequency bins. Since frequency
resolution is equal to $\Delta f = f_s/N$, the frequency resolution is
1kHz. However, only the first half of the bins give real results
(critical sampling rate is twice nyquist frequency), so we are left
with 1000 freq bins of 1kHz resolution. Using the range equation we
can translate these frequency bins into distance bins, spaced 0.25m
apart. The max distance is 250m. The magnitude in each bin corresponds
to the strength of the signal at that distance.

Now we have 2 rows of 1000 elements each. If we add 98 rows of 1000
zeros each, and compute the fft for each column of 100, the first
column represents the signal strength between 0 and 0.25m for each
angle between -\pi and \pi radians?? The starting angle is the first row
and the ending angle is the last row. The last column is the 250m
distance for the same angles. Basically, we're left with the signal
strength at each angle and distance.

*** graphical rendering
The host PC takes the range/angle data from the FPGA and plots it
using matplotlib. See [[https://matplotlib.org/3.1.1/api/animation_api.html][this example]] and the [[https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.animation.FuncAnimation.html#matplotlib.animation.FuncAnimation][FuncAnimation]] documentation
for how to perform realtime plots with matplotlib. The host PC
simultaneously plots the realtime range and angle (using a polar plot,
where each point is a dB strength) and an incrementally updated (also
realtime) range-time plot. It provides the option to record both.
* Footnotes

[fn:1]S. He and M. Torkelson. A New Approach to Pipeline FFT
Processor. 1996.
